# awsome-knowledge-front-end
## 目录
### JavaScript
1. [数组问题1](#数组问题1)
2. [手写节流和防抖](#手写节流和防抖)
3. [介绍下Set、Map、WeakSet和WeakMap的区别](#set_map_weakset_weakmap)
4. [JavaScript包括哪些数据类型？请分别编写3种以上类型的判断函数？如isString](#js_datatype_isstring)
5. [编写一个JavaScript函数实时显示当前时间格式如年月日时分秒](#编写一个JavaScript函数实时显示当前时间格式如年月日时分秒)
6. [如何显示隐藏一个DOM元素](#如何显示隐藏一个DOM元素)
7. [如何添加html元素的事件处理有几种方法](#如何添加html元素的事件处理有几种方法)
8. [如何控制alert中的换行](#如何控制alert中的换行)
9. [判断一个字符串中出现次数最多的字符统计这个次数](#判断一个字符串中出现次数最多的字符统计这个次数)
10. [判断字符串是否是这样组成的第一个必须是字母后面可以是字母数字下划线总长度为5到20](#判断字符串是否是这样组成的第一个必须是字母后面可以是字母数字下划线总长度为5到20)
11. [请编写一个JavaScript函数parseQueryString，他的用途是把URL参数解析为一个对象，如：var url=“http://witmax.cn/index.php?key0=0&key1=1&key2=2”](#js_parsequerystring_url_toobj)
12. [在页面中有如下html，要求用闭包方式写一个JS从文本框中取出值，并在标签span中显示出来](#html_js_span)
13. [在IE6.0下面是不支持position：fixed的，请写一个JS使用<div id="box"></div>固定在页面的右下角](#ie6_position_fixed_div)
14. [请实现鼠标移到页面中的任意标签，显示出这个标签的基本矩形轮廓](#mouse_move_label)
15. [js的基础对象有哪些?window和document的常用的方法和属性列出来](#js_basic_object)
16. [JavaScript中如何对一个对象进行深度clone](#JavaScript中如何对一个对象进行深度clone)
17. [js中如何定义class?如何扩展protope](#class_prototype)
18. [ajax是什么?ajax的交互模型?同步和异步的区别?如何解决跨域问题](#ajax_async_sync)
19. [请给出异步加载js方案，不少于两种](#async_js)
20. [多浏览器检测通过什么](#多浏览器检测通过什么)
21. [关于window.onload()了解多少](#window_onload)
22. [如何让generator自动next（不通过next.next.next）](#generator_auto_next)
23. [promise原理](#promise原理)
24. [变量提升](#变量提升)
25. [let和const的闭包](#let和const的闭包)
26. [this的指向](#this的指向)
27. [哪个是true](#哪个是true)
28. [对象赋值之内存地址不变](#对象赋值之内存地址不变)
29. [new Number、==和===](#new_number)
30. [静态方法](#静态方法)
31. [输出什么7](#输出什么7)
32. [当我们做这些会发生什么](#当我们做这些会发生什么)
33. [输出什么8](#输出什么8)
34. [输出什么9](#输出什么9)
35. [事件传播的三个阶段是什么](#事件传播的三个阶段是什么)
36. [输出什么10](#输出什么10)
37. [输出什么11](#输出什么11)
38. [输出什么12](#输出什么12)
39. [对象判断相等](#对象判断相等)
40. [输出什么14](#输出什么14)
41. [所有对象都有原型](#所有对象都有原型)
42. [输出什么15](#输出什么15)
43. [输出什么16](#输出什么16)
44. [session可访问多长时间](#session可访问多长时间)
45. [输出什么17](#输出什么17)
46. [输出什么18](#输出什么18)
47. [输出什么19](#输出什么19)
48. [JavaScript全局执行上下文为你做了两件事全局对象和this关键字](#JavaScript全局执行上下文为你做了两件事全局对象和this关键字)
49. [输出什么20](#输出什么20)
50. [原型方法](#原型方法)
51. [输出什么22](#输出什么22)
52. [事件循环](#事件循环)
53. [当点击按钮时，event.target是什么](#click_button_event_target)
54. [当您单击该段落时日志输出是什么](#当您单击该段落时日志输出是什么)
55. [输出什么24](#输出什么24)
56. [输出什么25](#输出什么25)
57. [下面哪些值是falsy](#下面哪些值是falsy)
58. [输出什么26](#输出什么26)
59. [输出什么27](#输出什么27)
60. [输出什么28](#输出什么28)
61. [自己开发的框架或者库如何使用原型](#自己开发的框架或者库如何使用原型)
62. [目前JS对于异步的解决方案有哪些](#目前JS对于异步的解决方案有哪些)
63. [常用的ES6的语法有哪些](#常用的ES6的语法有哪些)
64. [vue如何解析模板](#vue如何解析模板)
65. [React的setState为何是异步渲染](#React的setState为何是异步渲染)
66. [hybrid和h5有何区别](#hybrid和h5有何区别)
67. [JavaScript中的一切都是](#JavaScript中的一切都是)
68. [输出什么29](#输出什么29)
69. [输出什么30](#输出什么30)
70. [setInterval方法的返回值是什么](#setInterval方法的返回值是什么)
71. [输出什么31](#输出什么31)
72. [输出什么32](#输出什么32)
73. [返回值是什么](#返回值是什么)
74. [输出什么33](#输出什么33)
75. [输出什么34](#输出什么34)
76. [输出什么35](#输出什么35)
77. [输出什么36](#输出什么36)
78. [输出什么37](#输出什么37)
79. [输出什么38](#输出什么38)
80. [输出什么39](#输出什么39)
81. [输出什么40](#输出什么40)
82. [输出什么41](#输出什么41)
83. [输出什么42](#输出什么42)
84. [输出什么43](#输出什么43)
85. [输出什么44](#输出什么44)
86. [输出什么45](#输出什么45)
87. [输出什么46](#输出什么46)
88. [输出什么47](#输出什么47)
89. [输出什么48](#输出什么48)
90. [输出什么49](#输出什么49)
91. [输出什么50](#输出什么50)
92. [输出什么51](#输出什么51)
93. [输出什么52](#输出什么52)
94. [使用哪个构造函数可以成功继承Dog类](#使用哪个构造函数可以成功继承Dog类)
95. [输出什么53](#输出什么53)
96. [输出什么54](#输出什么54)
97. [输出什么55](#输出什么55)
98. [输出什么56](#输出什么56)
99. [如何能打印出consolelog语句后注释掉的值](#如何能打印出consolelog语句后注释掉的值)
100. [输出什么57](#输出什么57)
101. [输出什么58](#输出什么58)
102. [输出什么59](#输出什么59)
103. [输出什么60](#输出什么60)
104. [输出什么61](#输出什么61)
105. [以下是个纯函数么](#以下是个纯函数么)
106. [输出什么62](#输出什么62)
107. [输出什么63](#输出什么63)
108. [输出什么64](#输出什么64)
109. [输出什么65](#输出什么65)
110. [输出什么66](#输出什么66)
111. [输出什么67](#输出什么67)
112. [输出什么68](#输出什么68)
113. [什么样的信息将被打印](#什么样的信息将被打印)
114. [哪个选项是将hasName设置为true的方法，前提是不能将true作为参数传递](#hasName_true_params)
115. [实现一个函数判断输入是不是回文字符串](#实现一个函数判断输入是不是回文字符串)
116. [实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem(key,value)和getItem(key)](#stotage_single_setitem_getitem)
117. [解析字符串的值使之变成算式如‘1-10*2+1/4’（知衣科技）](#parse_string_compute)
118. [说说事件流（字节跳动）](#event)
119. [现在有一个进度条，进度条中间有一串文字，当我的进度条覆盖了文字之后，文字要与进度条反色，怎么实现](#process_font_over_color_change)
120. [有一个函数A和函数B，请你实现B继承A,分别说说他们的优缺点（有赞）](#a_b_inherit)
121. [描述一下this（有赞）](#描述一下this)
122. [图片懒加载](#图片懒加载)
123. [实现页面加载进度条](#实现页面加载进度条)
124. [事件委托](#事件委托)
125. [实现extend函数](#实现extend函数)
126. [为什么会有跨域的问题以及解决方式(大搜车)](#为什么会有跨域的问题以及解决方式)
127. [jsonp原理postMessage原理](#jsonp原理postMessage原理)
128. [实现拖拽功能比如把5个兄弟节点中的最后一个节点拖拽到节点1和节点2之间](#实现拖拽功能比如把5个兄弟节点中的最后一个节点拖拽到节点1和节点2之间)
129. [动画setTimeout何时执行requestAnimationFrame的优点](#动画setTimeout何时执行requestAnimationFrame的优点)
130. [手写parseInt的实现：要求简单一些，把字符串型的数字转化为真正的数字即可，但不能使用JS原生的字符串转数字的API，比如Number()](#parseint_no_number)
131. [编写分页器组件的时候为了减少服务端查询次数点击下一页怎样能确保还有数据可以加载请求数据不会为空](#编写分页器组件的时候为了减少服务端查询次数点击下一页怎样能确保还有数据可以加载请求数据不会为空)
132. [ES6新增了哪些特性，使用过哪些，也有当场看代码说输出结果的](#es6_feature)
133. [JS模块化的实践](#JS模块化的实践)
134. [JS模块化的实践](#JS模块化的实践)
135. [promise的实现原理进一步会问asyncawait是否使用过](#promise的实现原理进一步会问asyncawait是否使用过)
136. [实现gulp的功能](#实现gulp的功能)
137. [使用前端框架angularvuereact带来哪些好处相对于使用jQuery](#使用前端框架angularvuereact带来哪些好处相对于使用jQuery)
138. [vue双向数据绑定的实现](#vue双向数据绑定的实现)
139. [单页应用如何实现其路由功能](#单页应用如何实现其路由功能)
140. [手动实现callapplybind](#手动实现callapplybind)
141. [观察者模式](#观察者模式)
142. [浅拷贝和深拷贝](#浅拷贝和深拷贝)
143. [数组去重](#数组去重)
144. [如何实现一个倒计时功能类似于蘑菇街中的秒杀](#如何实现一个倒计时功能类似于蘑菇街中的秒杀)
145. [怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢？（蘑菇街）](#es6_this_function_this)
146. [说一下同源策略](#说一下同源策略)
147. [一个DOM树，其中有两个节点，找出这两个节点公共的父节点？ (有赞)](#dom_two_node)
148. [说一下强缓存和协商缓存？ （浏览器的缓存机制也需要很清楚） (有赞) ](#strong_cache_negotiate_cache)
149. [为什么数据库使用的是mongodb而不是mysql](#为什么数据库使用的是mongodb而不是mysql)
150. [什么是xss如何防止xss](#什么是xss如何防止xss)
151. [作用域](#作用域)
152. [语法题](#语法题)
153. [promise和callback的区别(海康)](#promise和callback的区别海康)
154. [axios封装用什么处理异常其原理其返回的是什么海康](#axios封装用什么处理异常其原理其返回的是什么海康)
155. [正则题](#正则题)
156. [闭包(海康)](#闭包海康)
157. [原始类型有哪几种null是对象嘛](#原始类型有哪几种null是对象嘛)
158. [对象类型和原始类型的不同之处函数参数是对象会发生什么问题](#对象类型和原始类型的不同之处函数参数是对象会发生什么问题)
159. [typeof是否能正确判断类型instanceof能正确判断对象的原理是什么](#typeof是否能正确判断类型instanceof能正确判断对象的原理是什么)
160. [==和===有什么区别](#==和===有什么区别)
161. [如何正确判断this箭头函数的this是什么](#如何正确判断this箭头函数的this是什么)
162. [如何理解原型如何理解原型链](#如何理解原型如何理解原型链)
163. [什么是提升什么是暂时性死区varlet及const区别](#什么是提升什么是暂时性死区varlet及const区别)
164. [原型如何实现继承Class如何实现继承Class本质是什么](#原型如何实现继承Class如何实现继承Class本质是什么)
165. [为什么要使用模块化都有哪几种方式可以实现模块化各有什么特点](#为什么要使用模块化都有哪几种方式可以实现模块化各有什么特点)
166. [Proxy可以实现什么功能](#Proxy可以实现什么功能)
167. [map, filter, reduce 各自有什么作用？](#mapfilterreduce各自有什么作用)
168. [并发与并行的区别](#并发与并行的区别)
169. [什么是回调函数?回调函数有什么缺点?如何解决回调地狱问题](#什么是回调函数回调函数有什么缺点如何解决回调地狱问题)
170. [你理解的Generator是什么](#你理解的Generator是什么)
171. [Promise的特点是什么?分别有什么优缺点?什么是Promise链?Promise构造函数执行和then函数执行有什么区别?](#Promise的特点是什么分别有什么优缺点什么是Promise链Promise构造函数执行和then函数执行有什么区别)
172. [async及await的特点?它们的优点和缺点分别是什么?await原理是什么?](#async及await的特点它们的优点和缺点分别是什么await原理是什么)
173. [setTimeout,setInterval,requestAnimationFrame各有什么特点](#setTimeoutsetIntervalrequestAnimationFrame各有什么特点)
174. [手写Promise](#手写Promise)
175. [异步代码执行顺序?解释一下什么是EventLoop?(坚果云)](#异步代码执行顺序解释一下什么是EventLoop坚果云)
176. [进程与线程区别?JS单线程带来的好处?](#进程与线程区别JS单线程带来的好处)
177. [什么是执行栈](#什么是执行栈)
178. [Node中的EventLoop和浏览器中的有什么区别?process.nexttick执行顺序?](#Node中的EventLoop和浏览器中的有什么区别processnexttick执行顺序)
179. [使用正则表达式验证邮箱格式](#使用正则表达式验证邮箱格式)
180. [判断数组(大搜车)](#判断数组)
181. [实现indexof(大搜车)](#实现indexof)
182. [promise.all 如果三个请求中第一个发生错误是会继续执行吗（海康）](#promiseall如果三个请求中第一个发生错误是会继续执行吗)
183. [取消promise（海康）](#取消promise)
184. [后端的MVC(海康二面)](#后端的MVC)
185. [简单讲讲适配器模式(海康二面)](#简单讲讲适配器模式)
186. [rustful接口原则(海康二面)](#rustful接口原则)
## 题目

### JavaScript

1. ####  数组问题1
为什么 `["1","2","3"].map(parseInt)` 返回 `[1,NaN,NaN]`
##### 开始
![Screenshot from 2019-04-18 09-48-49](https://user-images.githubusercontent.com/36500514/56331706-124a8700-61c0-11e9-9ed6-8dac78d596ae.png)

答案是肯定的，那为什么不是 `[1,2,3]` 呢？

##### 知识
首先看看官网上：

[paserInt的用法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)

`parseInt()` 函数解析一个字符串参数，通过基数解析，返回一个整数或者 `NAN`

`parseInt()` 的两个参数分别是 `string` 和 `radix`

`string` 就是要解析的字符串，`radix` 就是基数

注意：
- 基数不在`2-36`之间，则返回值就是 `NAN`

- map
遍历数组，将数组中的每一个元素调用定义的回调函数，返回包含结果的数组

`map()` 的第一个参数是回调函数，回调函数的三个参数分别是 `currentValue/index/arr`

`currentValue` 是当前值，`index` 当前值的索引，`arr` 当前元素属于的数组对象

##### 解析
那么回到这道题中，`['1','2','3'].map(parseInt)` 就可以等于

['1','2','3'].map(function('1',0))，

['1','2','3'].map(function('2',1))，

['1','2','3'].map(function('3',2))

接着

parseInt('1',0),

parseInt('2',1),

parseInt('3',2)

那么，第一个字符串‘1’基于基数`0`也就是`10`进制返回值是`1`

第二个的基数是`1`小于`2`，返回值为 `NAN`

第三个中`3`是没有`2`进制的，返回值为 `NAN`

##### 延伸
```javascript
function part(fn) {
    return (...rest) => {
        return fn.call(this, rest[0])
    }
}
let a = ['1', '2', '3']
a.map(part(parseInt))
//  [1, 2, 3]
```
为什么加个函数就返回没问题了呢

##### 解析
```javascript
function part(fn) {
    return (...rest) => {
        // console.log('rest', rest)
        // rest (3) ["1", 0, Array(3)]
        // rest (3) ["2", 1, Array(3)]
        // rest (3) ["3", 2, Array(3)]

        // console.log('rest[0]', rest[0])
        // rest 1
        // rest 2
        // rest 3

        // console.log(fn)
        // parseInt() { [native code] }

        // console.log('fn.call(this, rest[0])', fn.call(this, rest[0]))
        //fn.call(this, rest[0]) 1 
        //fn.call(this, rest[0]) 2 
        //fn.call(this, rest[0]) 3
        return fn.call(this, rest[0])
    }
}
let a = ['1', '2', '3']
a.map(part(parseInt))
//  [1, 2, 3]
```
1. 先`...rest`获取全部参数，即rest
2. 再获取每个参数中的索引为0的值，即rest[0]
3. fn就是`parseInt()`函数
4. 接着fn用`call`继承`rest[0]`，执行函数就简化为`parserInt('1'),parserInt('2'),parserInt('3')`
5. 最后返回的值就是[1,2,3]
##### 参考文献
[为什么["1","2","3"].map(parseInt) 返回[1,NaN,NaN]？](https://juejin.im/post/5b7298de51882561126f0389)

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

2. ####  手写节流和防抖
##### 防抖
- 防抖（`debounce`）
所谓防抖，就是指触发事件后在 `n` 秒内函数只能执行一次，如果在 `n` 秒内又触发了事件，则会重新计算函数执行时间。
防抖函数分为非立即执行版和立即执行版。
- 非立即执行：触发事件后函数不会立即执行，而是在n秒后执行，如果在n秒内又触发了事件，则会重新计算函数执行时间。
```js
    function debounce(func, wait) {
        let timeout
        return function () {
            let context = this
            let args = arguments
            if (timeout) clearTimeout(timeout)
            timeout = setTimeout(() => {
                func.apply(context, args)
            }, wait)
        }
    }
```
背景：产生事件时，首先执行立即执行函数 `setTimeout`。
当鼠标移动时，会产生 `setTimeout`，每移动一次就 `timeout` 增加一次，
当 `timeout` 有值时，就销毁定时器。如果停止移动，就不触发定时器，
那么 `timeout` 没有值，那么就执行加一操作。

获取 `this` 和参数，为了让 `debounce` 函数最终返回的函数 `this` 指向不变以及依旧能接受参数。

完整版：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #con {
            height: 100%;
            width: 100%;
            position: absolute;
            line-height: 600px;
            text-align: center;
            color: #ff0000;
            background-color: #ffff00;
            font-size: 100px;
        }
    </style>
</head>
<body>
<div id="con">
</div>
<script>
    let num = 1
    let con = document.getElementById('con')

    function count() {
        con.innerHTML = num++
    }

    function debounce(func, wait) {
        let timeout
        return function () {
            let context = this
            let args = arguments
            if (timeout) clearTimeout(timeout)
            timeout = setTimeout(() => {
                func.apply(context, args)
            }, wait)
        }
    }

    con.onmousemove = debounce(count, 1000)
</script>
</body>
</html>

```

[在线预览](https://codepen.io/qiufeihong2018/pen/BaBdXvK)

- 立即执行：触发事件后函数会立即执行，然后n秒后不触发事件才能继续执行函数。
```javascript
    function debounce(func, wait) {
        let timeout
        return function () {
            let context = this
            let args = arguments
            if (timeout) clearTimeout(timeout)
            console.log('timeout',timeout)
            let callNow = !timeout
            timeout = setTimeout(() => {
                timeout = null
            }, wait)
            if (callNow) func.apply(context, args)
        }
    }
```
当鼠标移动触发事件，进入 `debounce` 方法中。当执行 `setTimeout` 方法时，`timeout` 为 `null`，等一秒后再执行。在回到 `context/args` 赋值，如果此时 `timeout` 为 `null` 则不清除定时器。
并且 `callNow` 为 `ture`，`callNow` 为 `ture`，那么执行加一操作。

完整版本：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #con {
            height: 100%;
            width: 100%;
            position: absolute;
            line-height: 600px;
            text-align: center;
            color: #ff0000;
            background-color: #ffff00;
            font-size: 100px;
        }
    </style>
</head>
<body>
<div id="con">
</div>
<script>
    let num = 1
    let con = document.getElementById('con')

    function count() {
        con.innerHTML = num++
    }

    function debounce(func, wait) {
        let timeout
        return function () {
            let context = this
            let args = arguments
            if (timeout) clearTimeout(timeout)
            let callNow = !timeout
            timeout = setTimeout(() => {
                timeout = null
            }, wait)
            if (callNow) func.apply(context, args)
        }
    }

    con.onmousemove = debounce(count, 1000)
</script>
</body>
</html>

```

[在线预览](https://codepen.io/qiufeihong2018/pen/RwbZXvb)

###### 双剑合璧
需要立即执行，则加上第三个参数，否则不加。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #con {
            height: 100%;
            width: 100%;
            position: absolute;
            line-height: 600px;
            text-align: center;
            color: #ff0000;
            background-color: #ffff00;
            font-size: 100px;
        }
    </style>
</head>
<body>
<div id="con">
</div>
<script>
    let num = 1
    let con = document.getElementById('con')

    function count() {
        con.innerHTML = num++
    }

    function debounce(func, wait, immediate) {
        let timeout
        return function () {
            let context = this
            let args = arguments
            if (timeout) clearTimeout(timeout)
            if (immediate) {
                let callNow = !timeout
                timeout = setTimeout(() => {
                    timeout = null
                }, wait)
                if (callNow) func.apply(context, args)
            } else {
                timeout = setTimeout(() => {
                    func.apply(context, args)
                }, wait)
            }
        }
    }

    con.onmousemove = debounce(count, 1000)
</script>
</body>
</html>

```
###### 应用场景

- 窗口大小变化，调整样式
```
window.addEventListener('resize', debounce(handleResize, 200));
```
- 搜索框，输入后1000毫秒搜索
```
debounce(fetchSelectData, 1000);
```
- 表单验证，输入1000毫秒后验证
```
debounce(validator, 1000);
```

##### 手写+测试(坚果云)
我是这么写的
```js
function debounce(fun, time) {
    let now = new Date()
    console.log(`debounce-now-${now}`)
    let timeStamp = null
    return function () {
        if (timeStamp) clearTimeout(timeStamp)
        timeStamp = setTimeout(fun, time)
    }
}

function A() {
    let now = new Date()
    console.log(`A-now-${now}`)
}
// test1
setTimeout(debounce(A, 10000), 1000)
setTimeout(debounce(A, 10000), 2000)
// debounce-now-Thu Oct 03 2019 10:19:40 GMT+0800 (GMT+08:00)
// debounce-now-Thu Oct 03 2019 10:19:40 GMT+0800 (GMT+08:00)
// A-now-Thu Oct 03 2019 10:19:51 GMT+0800 (GMT+08:00)
// A-now-Thu Oct 03 2019 10:19:52 GMT+0800 (GMT+08:00)

// test2
let handle = debounce(A, 10000)
setTimeout(handle, 1000)
setTimeout(handle, 2000)
// debounce-now-Thu Oct 03 2019 10:21:20 GMT+0800 (GMT+08:00)
// A-now-Thu Oct 03 2019 10:21:32 GMT+0800 (GMT+08:00)

// test3
let handle = debounce(A, 10000)
setTimeout(handle, 10000)
setTimeout(handle, 10000)
// debounce-now-Thu Oct 03 2019 10:23:07 GMT+0800 (GMT+08:00)
// A-now-Thu Oct 03 2019 10:23:27 GMT+0800 (GMT+08:00)
```

[Jest unit test for a debounce function](https://stackoverflow.com/questions/52224447/jest-unit-test-for-a-debounce-function)

可以通过 `jest` 来测试
```js
const _ = require('lodash');
import * as sinon from 'sinon';

let clock;

beforeEach(() => {
  clock = sinon.useFakeTimers();
});

afterEach(() => {
  clock.restore();
});

test('debounce', () => {
  const func = jest.fn();
  const debouncedFunc = _.debounce(func, 1000);

  // Call it immediately
  debouncedFunc();
  expect(func).toHaveBeenCalledTimes(0); // func not called

  // Call it several times with 500ms between each call
  for(let i = 0; i < 10; i++) {
    clock.tick(500);
    debouncedFunc();
  }
  expect(func).toHaveBeenCalledTimes(0); // func not called

  // wait 1000ms
  clock.tick(1000);
  expect(func).toHaveBeenCalledTimes(1);  // func called
});
```
##### 节流
连续触发事件，但是在 `n` 秒中只执行一次。节流会稀释函数的执行频率。

对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。

时间戳版：
```javascript
    function throttle(func, wait) {
        var previous = 0
        return function () {
            let now = Date.now()
            let context = this
            let args = arguments
            if (now - previous > wait) {
                func.apply(context, args)
                previous = now
            }
        }
    }
```
在持续触发事件过程中，函数会立即执行，并且每`1`秒执行一次。

当时间每过去`n`秒后，执行加一事件。
完整版
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #con {
            height: 100%;
            width: 100%;
            position: absolute;
            line-height: 600px;
            text-align: center;
            color: #ff0000;
            background-color: #ffff00;
            font-size: 100px;
        }
    </style>
</head>
<body>
<div id="con">
</div>
<script>
    let num = 1
    let con = document.getElementById('con')

    function count() {
        con.innerHTML = num++
    }

    function throttle(func, wait) {
        var previous = 0
        return function () {
            let now = Date.now()
            let context = this
            let args = arguments
            if (now - previous > wait) {
                func.apply(context, args)
                previous = now
            }
        }
    }

    con.onmousemove = throttle(count, 1000)
</script>
</body>
</html>

```

[在线预览](https://codepen.io/qiufeihong2018/pen/xxKLvNQ)

定时器版：
```javascript
    function throttle(func, wait) {
        let timeout
        return function () {
            let context = this
            let args = arguments
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null
                    func.apply(context, args)
                }, wait)
            }
        }
    }
```
持续触发事件时，每当 `n` 秒后执行一次，`timeout` 设为空。当为空又开始执行。

在持续触发事件的过程中，函数不会立即执行，并且每 `1s` 执行一次，在停止触发事件后，函数还会再执行一次。

我们应该可以很容易的发现，其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。


完整版：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #con {
            height: 100%;
            width: 100%;
            position: absolute;
            line-height: 600px;
            text-align: center;
            color: #ff0000;
            background-color: #ffff00;
            font-size: 100px;
        }
    </style>
</head>
<body>
<div id="con">
</div>
<script>
    let num = 1
    let con = document.getElementById('con')

    function count() {
        con.innerHTML = num++
    }

    function throttle(func, wait) {
        let timeout
        return function () {
            let context = this
            let args = arguments
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null
                    func.apply(context, args)
                }, wait)
            }
        }
    }

    con.onmousemove = throttle(count, 1000)
</script>
</body>
</html>
```

[在线预览](https://codepen.io/qiufeihong2018/pen/aboyegQ)


双剑合璧版：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #con {
            height: 100%;
            width: 100%;
            position: absolute;
            line-height: 600px;
            text-align: center;
            color: #ff0000;
            background-color: #ffff00;
            font-size: 100px;
        }
    </style>
</head>
<body>
<div id="con">
</div>
<script>
    let num = 1
    let con = document.getElementById('con')

    function count() {
        con.innerHTML = num++
    }

    function throttle(func, wait, type) {
        if (type === 1) {
            console.log('css')
            // 时间戳版：
            let previous = 0
            return function () {
                let now = Date.now()
                let context = this
                let args = arguments
                if (now - previous > wait) {
                    previous = now
                    func.apply(context, args)
                }
            }
        } else if (type === 2) {
            // 定时器版：
            let timeout
            return function () {
                let context = this
                let args = arguments
                if (!timeout) {
                    timeout = setTimeout(() => {
                        timeout = null
                        func.apply(context, args)
                    }, wait)
                }
            }
        }
    }

    con.onmousemove = throttle(count, 1000, 2)
</script>
</body>
</html>

```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

3. #### <a id="set_map_weakset_weakmap"></a>  介绍下Set、Map、WeakSet和WeakMap的区别(难))
##### 集合 Set
`ES6` 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的。
`Set` 本身是一种构造函数，用来生成 `Set` 数据结构。

```javascript
new Set([iterable]);
```

![Screenshot from 2019-05-05 10-58-15](https://user-images.githubusercontent.com/36500514/57187656-e996f100-6f24-11e9-91c3-ddbcb2adcd69.png)                                                                                                                                                                                                                                                            

![Screenshot from 2019-05-05 11-01-34](https://user-images.githubusercontent.com/36500514/57187672-2cf15f80-6f25-11e9-8de7-8af871d42e84.png)                                                                                                                                                                                                                                                            
`Set` 对象存储原始值或是对象引用的唯一值。
向 `Set` 加入值的时候，不会发生类型转换，所以 `1` 和`‘1’`是两个不同的值。`Set` 用`‘Same-value-zero equality’`算法来判断两个值是否不同，它类似于精确相等运算符（`===`），主要的区别是 `NAN` 等于自身，而精确相等运算符认为 `NaN` 不等于自身。

![Screenshot from 2019-05-05 11-09-15](https://user-images.githubusercontent.com/36500514/57187740-3d560a00-6f26-11e9-9d89-889f2724ba3c.png)                                                                                                                                                                                                                                                            

- Set 实例属性
  - constructor：构造函数
  - size：元素数量

![Screenshot from 2019-05-05 11-13-06](https://user-images.githubusercontent.com/36500514/57187784-c705d780-6f26-11e9-904e-d73b04cd0a96.png)                                                                                                                                                                                                                                                                                                                                                

- Set 实例方法

  - 操作方法 - add(value):相当 array 里的 push，新增 - delete(vallue):删除集合中 value - has(value):判断集合是否存在 value - clear():清空集合

    ![Screenshot from 2019-05-05 11-18-25](https://user-images.githubusercontent.com/36500514/57187828-85296100-6f27-11e9-86f9-e71668eeecd9.png)                                                                                                                                                                                                                                                                                                                                                
    ![Screenshot from 2019-05-05 11-21-06](https://user-images.githubusercontent.com/36500514/57188155-6bd6e380-6f2c-11e9-9fc6-8505e81d3f1c.png)                                                                                                                                                                                                                                                                                                                                                

  - 遍历方法（遍历顺序为插入顺序） - keys():返回一个包含集合中所有键的迭代器 - values():返回一个包含集合中所有值的迭代器 - entries():返回一个包含 Set 对象中所有元素的键值对迭代器 - forEach(callback,this):用于对集合成员执行回调操作，如果提供了参数，回调中的 this 就是这个参数，没有返回值

    ![Screenshot from 2019-05-05 11-40-27](https://user-images.githubusercontent.com/36500514/57188028-9cb61900-6f2a-11e9-94d1-def917008ad9.png)                                                                                                                                                                                                                                                                                                                                                
    Set 可默认遍历，默认迭代器生成函数是 values() 方法

    ![Screenshot from 2019-05-05 11-45-00](https://user-images.githubusercontent.com/36500514/57188066-3aa9e380-6f2b-11e9-9422-1dc228dde10e.png)                                                                                                                                                                                                                                                                                                                                                
    所以， Set 可以使用 map、filter 方法

    ![Screenshot from 2019-05-05 11-47-40](https://user-images.githubusercontent.com/36500514/57188099-9aa08a00-6f2b-11e9-9f00-050c9fcce47d.png)                                                                                                                                                                                                                                                                                                                                                
    因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）

    ![Screenshot from 2019-05-05 11-52-29](https://user-images.githubusercontent.com/36500514/57188141-477b0700-6f2c-11e9-8a97-71ee8961738b.png)                                                                                                                                                                                                                                                                                                                                                
    差集还是有问题的

##### WeakSet
`WeakSet` 对象允许将弱引用对象储存在一个集合中
与 `Set` 的区别：

- 前者只能存储对象引用，不能存放值，而 Set 对象都可以
- 前者对象中存储的对象值都是被弱引用的，即垃圾回收机制不考虑其对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑改对象还存在于 WeakSet 中）。WeakSet 对象里有多少哥成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束后，有的成员可能取不到了（被垃圾回收），其实是无法被遍历的，也没法拿到它的所有元素

- 属性
  - constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数

![Screenshot from 2019-05-05 13-21-40](https://user-images.githubusercontent.com/36500514/57188872-bcecd480-6f38-11e9-875a-d5f505ac6203.png)                                                                                                                                                                                                                                                                                                                                                

- add(value):在 WeakSet 对象中添加一个元素 value
- has(value):判断 WeakSet 对象中是否包含 value
- delete(value):删除元素 value
- clear():清空所有元素

  ![Screenshot from 2019-05-05 13-26-05](https://user-images.githubusercontent.com/36500514/57188898-5ae09f00-6f39-11e9-8777-5da20be804da.png)                                                                                                                                                                                                                                                                                                                                                

##### 字典(Map)
集合和字典的区别：

- 共同点：集合和字典可以存储不重复的值
- 异点：集合是[value,value]的形式储存元素，字典是[key,value]的形式储存

![Screenshot from 2019-05-05 13-32-53](https://user-images.githubusercontent.com/36500514/57188949-4ea91180-6f3a-11e9-94ca-b27d5285f517.png)                                                                                                                                                                                                                                                                                                                                                

任何具有 `Iterator` 接口且每个成员都是一个双元素的数组的数据结构都可以当作`Map`构造函数的参数

![Screenshot from 2019-05-05 13-38-00](https://user-images.githubusercontent.com/36500514/57188989-076f5080-6f3b-11e9-9119-46764be1f66d.png)                                                                                                                                                                                                                                                                                                                                                
![Screenshot from 2019-05-05 13-38-23](https://user-images.githubusercontent.com/36500514/57189021-65039d00-6f3b-11e9-863b-11a2d6957614.png)                                                                                                                                                                                                                                                                                                                                                

如果读取一个未知的键，则返回 `undefined`。

![Screenshot from 2019-05-05 13-40-12](https://user-images.githubusercontent.com/36500514/57189015-52896380-6f3b-11e9-8aa8-7bb4c95a17ba.png)                                                                                                                                                                                                                                                                                                                                                
注意，只有对同一个对象的引用，`Map` 结构才将其视为同一个键。这一点要非常小心。

![Screenshot from 2019-05-05 13-42-57](https://user-images.githubusercontent.com/36500514/57189035-b9a71800-6f3b-11e9-98e7-84209a5345c2.png)                                                                                                                                                                                                                                                            
![Screenshot from 2019-05-05 13-43-03](https://user-images.githubusercontent.com/36500514/57189036-bca20880-6f3b-11e9-9375-9cba418b3745.png)                                                                                                                                                                                                                                                            
上面代码的 `set` 和 `get` 方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此 `get` 方法无法读取该键，返回 `undefined`。

由上可知，`Map` 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（`clash`）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

如果 `Map` 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，`Map` 将其视为一个键，比如 `0` 和 `-0` 就是一个键，布尔值 `true` 和字符串 `true` 则是两个不同的键。另外，`undefined` 和 `null` 也是两个不同的键。虽然 NaN 不严格相等于自身，但 `Map` 将其视为同一个键。

![Screenshot from 2019-05-05 13-48-31](https://user-images.githubusercontent.com/36500514/57189081-7ef1af80-6f3c-11e9-8eda-e68934aa153a.png)                                                                                                                                                                                                                                                            

`Map` 的属性及方法

- 属性：
  - constructor：构造函数
  - size：返回字典中所包含的元素个数

![Screenshot from 2019-05-05 13-50-59](https://user-images.githubusercontent.com/36500514/57189100-d42dc100-6f3c-11e9-82d8-95c366079193.png)                                                                                                                                                                                                                                                            

- 操作方法：

  - set(key, value)：向字典中添加新元素
  - get(key)：通过键查找特定的数值并返回
  - has(key)：判断字典中是否存在键 key
  - delete(key)：通过键 key 从字典中移除对应的数据
  - clear()：将这个字典中的所有元素删除

- 遍历方法
  - Keys()：将字典中包含的所有键名以迭代器形式返回
  - values()：将字典中包含的所有数值以迭代器形式返回
  - entries()：返回所有成员的迭代器
  - forEach()：遍历字典的所有成员

![Screenshot from 2019-05-05 13-53-44](https://user-images.githubusercontent.com/36500514/57189137-3686c180-6f3d-11e9-99f7-9da09d3c2e7b.png)                                                                                                                                                                                                                                                            
`Map` 结构的默认遍历器接口（`Symbol.iterator` 属性），就是 `entries` 方法。

![Screenshot from 2019-05-05 13-55-01](https://user-images.githubusercontent.com/36500514/57189156-646c0600-6f3d-11e9-9b33-d0895fd8cd89.png)                                                                                                                                                                                                                                                            

Map 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。

与其他数据结构的相互转换

- Map 转 Array

  ![Screenshot from 2019-05-05 13-57-58](https://user-images.githubusercontent.com/36500514/57189185-cd537e00-6f3d-11e9-8fb7-2bf8dae67698.png)                                                                                                                                                                                                                                                            
- Array 转 Map

![Screenshot from 2019-05-05 13-59-04](https://user-images.githubusercontent.com/36500514/57189197-f70ca500-6f3d-11e9-9617-664cf8d08204.png)                                                                                                                                                                                                                                                            

- Map 转 Object

  因为 Object 的键名都为字符串，而 Map 的键名为对象，所以转换的时候会把非字符串键名转为字符串键名。

  ![Screenshot from 2019-05-05 14-05-29](https://user-images.githubusercontent.com/36500514/57189259-dbee6500-6f3e-11e9-830d-69ca9b1f403e.png)                                                                                                                                                                                                                                                            
- Object 转 Map

  ![Screenshot from 2019-05-05 14-06-19](https://user-images.githubusercontent.com/36500514/57189263-f88a9d00-6f3e-11e9-9cd5-a501cd3c18d8.png)                                                                                                                                                                                                                                                            
- Map 转 JSON

  ![Screenshot from 2019-05-05 14-07-06](https://user-images.githubusercontent.com/36500514/57189268-15bf6b80-6f3f-11e9-968a-586bbd9f146f.png)                                                                                                                                                                                                                                                            

- JSON 转 Map

  ![Screenshot from 2019-05-05 14-09-41](https://user-images.githubusercontent.com/36500514/57189292-7189f480-6f3f-11e9-94d9-f942efa999b2.png)                                                                                                                                                                                                                                                            

##### WeakMap
   是一组键值对的集合，其中的键是弱引用对象，而值可以是任意的。
   注意，`WeakMap` 弱引用的只是键名，而不是键值。键值依然是正常引用。
   `WeakMap` 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的 `key` 则变成无效的），所以，`WeakMap` 的 `key` 是不可枚举的。

- 属性：
  - constructor：构造函数
- 方法：
  - has(key)：判断是否有 key 关联对象
  - get(key)：返回 key 关联对象（没有则则返回 undefined）
  - set(key)：设置一组 key 关联对象
  - delete(key)：移除 key 的关联对象

##### 总结：
- Set
  - 无序且不重复的
  - [value，value]，键值和键名重复
  - 可以遍历，方法有：add、delete、has、clear
- WeakSet
  - 成员都是对象
  - 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏
  - 不能遍历，方法有：add、delete、has、clear
- Map
  - 本质上是键值对的集合，字典
  - 可以遍历，方法：set、delete、has、get、clear
  - 可以跟各种数据格式转换
- WeakMap
  - 只接受对象作为键名（null 除外），不接受其他类型的值作为键名
  - 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
  - 不能遍历，方法有：get、set、has、delete

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

4. #### <a id="js_datatype_isstring"></a>  JavaScript包括哪些数据类型？请分别编写3种以上类型的判断函数？如isString
字符串、数字、布尔、数组、对象、`null`、`undefined`

`typeof`, `instanceof`, `isArray()`

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

5. ####  编写一个JavaScript函数实时显示当前时间格式如年月日时分秒
因为 `getMonth()` 方法返回值 `0-11` 的正整数，是从 `0` 开始的，获取的月份比正常月份少 `1`，所以需要加 `1`。
```js
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <input id="show" style="width:300px;"/>
  <script>
    function getTime(){
      var nowDate = new Date();
      var year = nowDate.getFullYear();
      var month = (nowDate.getMonth() + 1) > 10 ? nowDate.getMonth() + 1 : '0' + (nowDate.getMonth() + 1);
      var day = nowDate.getDate() > 10 ? nowDate.getDate() : '0' + nowDate.getDate();
      var hour = nowDate.getHours() > 10 ? nowDate.getHours() : (nowDate.getHours() == 0 ? 24 : '0' + nowDate.getHours());
      var minutes = nowDate.getMinutes() > 10 ? nowDate.getMinutes() : '0' + nowDate.getMinutes();
      var seconds = nowDate.getSeconds() > 10 ? nowDate.getSeconds() : '0' + nowDate.getSeconds();
      var str= year +"-" + month + "-" + day + " " + hour + ":" + minutes + ":" + seconds;
      document.getElementById("show").value = str;
    }
    window.setInterval("getTime()", 1000);
  </script>
</body>
</html>
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

6. ####  如何显示隐藏一个DOM元素
```css
/* 显示： */
object.style.display="block";
/* 隐藏： */
object.style.display="none";
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

7. ####  如何添加html元素的事件处理有几种方法
`html` 的元素的事件就只有组件自带的的那么几个，
如 `onclick,onmousedown` 等等都是调用脚本执行。

方法：
1. 在组件上直接激发事件；
2. 在页面加载的时候就调用脚本激发组件的某个事件；
3. 在后台利用后台代码强行执行组件的事件；
4. 为HTML元素的事件属性赋值；
5. 在JS中使用el.on*** = function() {…}；
6. 使用DOM2的添加事件的方法 addEventListener或attachEvent。

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

8. ####  如何控制alert中的换行
如何控制 `alert` 中的换行
```js
// \n 
alert("text\ntext");
```
---
[[↑] 回到顶部](#awsome-knowledge-front-end)

9. ####  判断一个字符串中出现次数最多的字符统计这个次数
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    var str = "abcdefgaddda";
    var obj = {};
    // 每个字符出现次数
    for (let i = 0; i < str.length; i++) {
        var key = str[i];
        typeof obj[key] === 'undefined' ? obj[key] = 1 : obj[key]++
    }
    var max = -1;
    var max_key = key;
    // 排序
    for (let key in obj) {
        if (max < obj[key]) {
            max = obj[key];
            max_key = key;
        }
    }
    document.write("字符:" + max_key + ",出现次数最多为:" + max + "次")
</script>
</body>
</html>
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

10. ####  判断字符串是否是这样组成的第一个必须是字母后面可以是字母数字下划线总长度为5到20

```js
var reg = /^[a-zA-Z][a-zA-Z_0-9]{4,19}$/
console.log(reg.test("11a__a1a__a1a__a1a__"))

```
---

[[↑] 回到顶部](#awsome-knowledge-front-end)

11. #### <a id="js_parsequerystring_url_toobj"></a> 请编写一个JavaScript函数parseQueryString，他的用途是把URL参数解析为一个对象，如：var url=“http://witmax.cn/index.php?key0=0&key1=1&key2=2”

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    function parseQueryString(url) {
        var result = {};
        var arr = url.split("?");
        if (arr.length <= 1) {
            return result;
        } else {
            arr = arr[1].split("&");
            arr.forEach(item => {
                let a = item.split('=')
                result[a[0]] = a[1]
            })
            return result;
        }
    }

    var url = "http://witmax.cn/index.php?key0=0&key1=1&key2=2";
    var ps = parseQueryString(url);
    console.log(ps)
</script>
</body>
</html>
```
---

[[↑] 回到顶部](#awsome-knowledge-front-end)

12. #### <a id="html_js_span"></a> 在页面中有如下html，要求用闭包方式写一个JS从文本框中取出值，并在标签span中显示出来

在页面中有如下 `html`:
```html
<div id="field">
<input type="text" value="User Name"/>
</div><span class="red"></span>
```
要求用闭包方式写一个 `JS` 从文本框中取出值并在标签 `span` 中显示出来。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<div id="firld">
    <input type="text" value="qiufeihong"/>
</div>
<span class="red"></span>

<script>
    var result = (function () {
        var value = document.getElementById("firld").children[0].value;
        var all = document.getElementsByTagName("span");
        for (let i = 0; i < all.length; i++) {
                all[i].innerHTML = value;
        }
    })();
</script>
</body>
</html>
```

[在线预览](https://codepen.io/qiufeihong2018/pen/aboqQBP?editors=1111)

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

13. #### <a id="ie6_position_fixed_div"></a> 在IE6.0下面是不支持position：fixed的，请写一个JS使用<div id="box"></div>固定在页面的右下角
##### 前提知识
1. window.onscroll
为当前页面的页面滚动事件添加事件处理函数
2. window.onresize
用来获取或设置当前窗口的 `resize` 事件的事件处理函数
3. window.onload
用于在网页加载完毕后立刻执行的操作，即当 `HTML` 文档加载完毕后，立刻执行某个方法
4. document.documentElement.scrollTop
获取滚动条位置
5. document.documentElement.clientWidth
获取浏览器窗口文档显示区域的宽度，不包括滚动条。
6. document.documentElement.clientHeight
获取浏览器窗口文档显示区域的高度，不包括滚动条。
7. document.documentElement.offsetWidth
获取 `DOM` 文档的根节点 `html` 元素对象的宽度，即 `offsetWidth=width+padding+border`，不包括 `margin`。
8. document.documentElement.offsetHeight
获取 `DOM` 文档的根节点 `html` 元素对象的高度，即 `offsetHeight=height+padding+border`，不包括 `margin`。
##### 解析
1. 当前页面的页面滚动、更改当前页面的大小和加载完成时执行下面方法
2. 获取div，获取滚动条位置
3. 浏览器窗口的宽度减去div的宽度为div的left属性的值
4. 浏览器窗口的高度减去div的高度为div的top属性的值

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        .tit {
            position: absolute;
            width: 100px;
            height: 100px;
            background: red;
        }
    </style>
</head>
<body>
<div id="box" class="tit"></div>
<script>
    window.onscroll = window.onresize = window.onload = () => {
        var getDiv = document.getElementById('box');
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        getDiv.style.left = document.documentElement.clientWidth - getDiv.offsetWidth + 'px';
        getDiv.style.top = document.documentElement.clientHeight - getDiv.offsetHeight + scrollTop + 'px';
    }
</script>
</body>
</html>
```
##### 课外知识
1. document.documentElement.scrollWidth
获取 `html` 元素对象内容的实际宽度，即 `html` 元素对象的滚动宽度。
2. document.documentElement.scrollHeight
获取 `html` 元素对象内容的实际高度，即 `html` 元素对象的滚动高度。
3. document.documentElement.clientLeft
获取 `html` 元素对象的左边框的宽度。
4. document.documentElement.clientTop
获取 `html` 元素对象的上边框的宽度。
5. document.doucmentElement.offsetLeft
获取 `html` 元素对象相对于整个页面文档的位置，也就是 `html` 元素的 `margin`。
6. document.documentElement.offsetTop
获取 `html` 元素对象相对于整个页面文档的位置，也就是 `html` 元素的 `margin`。
7. document.documentElement.scrollLeft
设置或获取页面文档向右滚动过的像素数。
8. document.documentElement.scrollTop
设置或获取页面文档向下滚动过的像素数。

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

14. #### <a id="mouse_move_label"></a> 请实现鼠标移到页面中的任意标签，显示出这个标签的基本矩形轮廓
请实现，鼠标移到页面中的任意标签，显示出这个标签的基本矩形轮廓。

##### 先前知识
1. document.body返回当前文档中的 `<body>` 元素或者 `<frameset>` 元素.
2. nodeType 属性返回以数字值返回指定节点的节点类型。
如果节点是元素节点，则 `nodeType` 属性将返回 `1`。
如果节点是属性节点，则 `nodeType` 属性将返回 `2`。
如果节点是文本节点，则 `nodeType` 属性将返回 `3`。
3. onmouseover 事件会在鼠标指针移动到指定的对象上时发生。
##### 解析
1. 获取body中的节点
2. 如果是元素节点，鼠标移动到上面添加边框，移出来恢复
3. 递归所有节点

``` html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        .tit {
            display: block;
            width: 100px;
            height: 100px;
            background: yellow;
        }
    </style>
</head>

<body>
    <div id="box" class="tit">div</div>
    <p class="tit">p</p>
    <a class="tit">a</a>
    <script>
        function mouseBorder(t) {
            var c = t.childNodes
            for (let i = 0; i < c.length; i++) {
                var d = c[i];
                if (d.nodeType == 1) {
                    d.onmouseover = function () {
                        this.style.border = '1px solid red'
                    }
                    d.onmouseout = function () {
                        this.style.border = ''
                    }
                    mouseBorder(d);
                }
            }
        }
        mouseBorder(document.body);
    </script>
</body>

</html>
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

15. #### <div id="js_basic_object"></div>js的基础对象有哪些?window和document的常用的方法和属性列出来

`String,Number,Boolean`

- Window:

方法：`setInterval,setTimeout,clearInterval,clearTimeout,alert,confirm,open`

属性：`name,parent,screenLeft,screenTop,self,top,status`

- Document

方法：`createElement,execCommand,getElementById,getElementsByName,getElementByTagName,write,writeln`

属性：`cookie,doctype,domain,documentElement,readyState,URL`

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

16. #### JavaScript中如何对一个对象进行深度clone
##### 解析
1. 为空且不为object类型返回自身
2. 根据原始值的类型创建同样类型的值
3. 遍历原始值，将原始值中的对象和属性拷贝到新值，并返回

不反对用 `Ext.ux.clone`，但是最好还是递归
```js
function cloneObject(o) {
    // 1. 是否是object,是否为空
    if (!o || 'object' !== typeof o) {
        return o;
    }

    // 2. 判断其是数组还是对象,并创建新的对象或数组
    var c = 'function' === typeof o.pop ? [] : {};

    // 3. 遍历对象或数组
    for (let p in o) {
        let v = o[p];
        v && 'object' === typeof v ? c[p] = cloneObject(v) : c[p] = v
    }
    return c;
}

a = {
    'name': 'qiufeihong'
}
b = cloneObject(a)
a.name = 'youyuxi'
console.log('a', a)
console.log('b', b)
```
---

[[↑] 回到顶部](#awsome-knowledge-front-end)

17. #### <div id="class_prototype"></div>js中如何定义class，如何扩展prototype？
```html
Ele.className = “***”; //***在css中定义，形式如下：.*** {…}

A.prototype.B = C;

A是某个构造函数的名字

B是这个构造函数的属性

C是想要定义的属性的值
```
---

[[↑] 回到顶部](#awsome-knowledge-front-end)

18. #### <div id="ajax_async_sync"></div>ajax是什么？ajax的交互模型？同步和异步的区别？如何解决跨域问题？
#####  ajax是什么
`Ajax` 是多种技术组合起来的一种浏览器和服务器交互技术，基本思想是允许一个互联网浏览器向一个远程页面/服务做异步的 `http` 调用，并且用收到的数据来更新一个当前 `web` 页面而不必刷新整个页面。该技术能够改进客户端的体验。包含的技术：

- XHTML：对应W3C的XHTML规范，目前是XHTML1.0。
- CSS：对应W3C的CSS规范，目前是CSS2.0
- DOM：这里的DOM主要是指HTML DOM，XML DOM包括在下面的XML中
- JavaScript：对应于ECMA的ECMAScript规范
- XML：对应W3C的XML DOM、XSLT、XPath等等规范
- XMLHttpRequest：对应WhatWG的Web Applications1.0规范（http://whatwg.org/specs/web-apps/current-work/）

#####  ajax的交互模型
`AJAX` 交互模型

同步：脚本会停留并等待服务器发送回复然后再继续

异步：脚本允许页面继续其进程并处理可能的回复

#####  同步和异步的区别
跨域问题简单的理解就是因为 `JS` 同源策略的限制，`a.com` 域名下的 `JS` 无法操作 `b.com` 或 `c.a.com` 下的对象，具体场景如下：

1. 如果是端口或者协议造成的跨域问题前端是无能为力的
2. 在跨域问题上，域仅仅通过URL的首部来识别而不会尝试判断相同的IP地址对应的域或者两个域是否对应一个IP

#####  没有同源策略限制的两大危险场景
据我了解，浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对 `Dom` 的查询。试想一下没有这样的限制上述两种动作有什么危险。

###### 没有同源策略限制的接口请求
有一个小小的东西叫 `cookie` 大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入 `Set-Cookie` 字段，然后下次再发请求的时候，浏览器会自动将 `cookie` 附加在 `HTTP` 请求的头字段 `Cookie` 中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景：

1. 你登陆了安全的网站www.yinhang.com,准备转账;
2. 突然右下脚跳出弹框;
3. 你没注意点了进去，然后由于没有同源策略的限制，它向www.yinhang.com发起了请求！ 很不幸你的银行账户被第三方恶意登录转账，等你回过神来，钱没了。

这就是 `CSRF` 攻击方式。

看了这波 `CSRF` 攻击我在想，即使有了同源策略限制，但 `cookie` 是明文的，还不是一样能拿下来。服务端可以设置  `httpOnly`，使得前端无法操作 `cookie`，如果没有这样的设置，像 `XSS` 攻击就可以去获取到 `cookieWeb` 安全测试之 `XSS`；设置 `secure`，则保证在 `https` 的加密通信中传输以防截获。

###### 没有同源策略限制的Dom查询
1. 有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进www.yinghang.com改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。
2. 睡眼朦胧的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，这个钓鱼网站做了什么呢？
```html
<iframe name="yinhang" src="www.yinhang.com"></iframe>
```
由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的 `Dom`
```js
const iframe = window.frames['yinhang']
const node = iframe.document.getElementById('你输入账号密码的Input')
console.log(`拿到了这个${node}，我还拿不到你刚刚输入的账号密码吗`)
```
由此我们知道，同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。

##### 前端对于跨域的解决办法
同源策略限制下接口请求的正确打开方式
###### 1. JSONP
在 `HTML` 标签里，一些标签比如 `script、img` 这样的获取资源的标签是没有跨域限制的，利用这一点，我们可以这样干：

后端写个小接口
```js
// 处理成功失败返回格式的工具
const {successBody} = require('../utli')
class CrossDomain {
  static async jsonp (ctx) {
    // 前端传过来的参数
    const query = ctx.request.query
    // 设置一个cookies
    ctx.cookies.set('tokenId', '1')
    // query.cb是前后端约定的方法名字，其实就是后端返回一个直接执行的方法给前端，由于前端是用script标签发起的请求，所以返回了这个方法后相当于立马执行，并且把要返回的数据放在方法的参数里。
    ctx.body = `${query.cb}(${JSON.stringify(successBody({msg: query.msg}, 'success'))})`
  }
}
module.exports = CrossDomain
```
简单版前端
```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <script type='text/javascript'>
      // 后端返回直接执行的方法，相当于执行这个方法，由于后端把返回的数据放在方法的参数里，所以这里能拿到res。
      window.jsonpCb = function (res) {
        console.log(res)
      }
    </script>
    <script src='http://localhost:9871/api/jsonp?msg=helloJsonp&cb=jsonpCb' type='text/javascript'></script>
  </body>
</html>
```
简单封装一下前端这个套路
```js
/**
 * JSONP请求工具
 * @param url 请求的地址
 * @param data 请求的参数
 * @returns {Promise<any>}
 */
const request = ({url, data}) => {
  return new Promise((resolve, reject) => {
    // 处理传参成xx=yy&aa=bb的形式
    const handleData = (data) => {
      const keys = Object.keys(data)
      const keysLen = keys.length
      return keys.reduce((pre, cur, index) => {
        const value = data[cur]
        const flag = index !== keysLen - 1 ? '&' : ''
        return `${pre}${cur}=${value}${flag}`
      }, '')
    }
    // 动态创建script标签
    const script = document.createElement('script')
    // 接口返回的数据获取
    window.jsonpCb = (res) => {
      document.body.removeChild(script)
      delete window.jsonpCb
      resolve(res)
    }
    script.src = `${url}?${handleData(data)}&cb=jsonpCb`
    document.body.appendChild(script)
  })
}
// 使用方式
request({
  url: 'http://localhost:9871/api/jsonp',
  data: {
    // 传参
    msg: 'helloJsonp'
  }
}).then(res => {
  console.log(res)
})
```
###### 2. 空iframe加form
细心的朋友可能发现，`JSONP` 只能发 `GET` 请求，因为本质上 `script` 加载资源就是 `GET`，那么如果要发 `POST` 请求怎么办呢？

后端写个小接口
```js
// 处理成功失败返回格式的工具
const {successBody} = require('../utli')
class CrossDomain {
  static async iframePost (ctx) {
    let postData = ctx.request.body
    console.log(postData)
    ctx.body = successBody({postData: postData}, 'success')
  }
}
module.exports = CrossDomain
```
前端
```js
const requestPost = ({url, data}) => {
  // 首先创建一个用来发送数据的iframe.
  const iframe = document.createElement('iframe')
  iframe.name = 'iframePost'
  iframe.style.display = 'none'
  document.body.appendChild(iframe)
  const form = document.createElement('form')
  const node = document.createElement('input')
  // 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话.
  iframe.addEventListener('load', function () {
    console.log('post success')
  })

  form.action = url
  // 在指定的iframe中执行form
  form.target = iframe.name
  form.method = 'post'
  for (let name in data) {
    node.name = name
    node.value = data[name].toString()
    form.appendChild(node.cloneNode())
  }
  // 表单元素需要添加到主文档中.
  form.style.display = 'none'
  document.body.appendChild(form)
  form.submit()

  // 表单提交后,就可以删除这个表单,不影响下次的数据发送.
  document.body.removeChild(form)
}
// 使用方式
requestPost({
  url: 'http://localhost:9871/api/iframePost',
  data: {
    msg: 'helloIframePost'
  }
})
```
###### 3. CORS
`CORS` 是一个 `W3C` 标准，全称是"跨域资源共享"（`Cross-origin resource sharing`）跨域资源共享 `CORS` 详解。看名字就知道这是处理跨域问题的标准做法。

浏览器将 `CORS` 请求分成两类：简单请求（`simple request`）和非简单请求（`not-so-simple request`）。

只要同时满足以下两大条件，就属于简单请求。
- 请求方法是以下三种方法之一：
 - HEAD
 - GET
 - POST
- HTTP的头信息不超出以下几种字段：
 - Accept
 - Accept-Language
 - Content-Language
 - Last-Event-ID
 - Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

i. 简单请求
后端
```js
// 处理成功失败返回格式的工具
const {successBody} = require('../utli')
class CrossDomain {
  static async cors (ctx) {
    const query = ctx.request.query
    // *时cookie不会在http请求中带上
    ctx.set('Access-Control-Allow-Origin', '*')
    ctx.cookies.set('tokenId', '2')
    ctx.body = successBody({msg: query.msg}, 'success')
  }
}
module.exports = CrossDomain
```
前端什么也不用干，就是正常发请求就可以，如果需要带 `cookie` 的话，前后端都要设置一下，下面那个非简单请求例子会看到。
```js
fetch(`http://localhost:9871/api/cors?msg=helloCors`).then(res => {
  console.log(res)
})
```
ii. 非简单请求
非简单请求会发出一次预检测请求，返回码是`204`，预检测通过才会真正发出请求，这才返回`200`。这里通过前端发请求的时候增加一个额外的`headers`来触发非简单请求。

后端
```js
// 处理成功失败返回格式的工具
const {successBody} = require('../utli')
class CrossDomain {
  static async cors (ctx) {
    const query = ctx.request.query
    // 如果需要http请求中带上cookie，需要前后端都设置credentials，且后端设置指定的origin
    ctx.set('Access-Control-Allow-Origin', 'http://localhost:9099')
    ctx.set('Access-Control-Allow-Credentials', true)
    // 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）
    // 这种情况下除了设置origin，还需要设置Access-Control-Request-Method以及Access-Control-Request-Headers
    ctx.set('Access-Control-Request-Method', 'PUT,POST,GET,DELETE,OPTIONS')
    ctx.set('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, t')
    ctx.cookies.set('tokenId', '2')

    ctx.body = successBody({msg: query.msg}, 'success')
  }
}
module.exports = CrossDomain
```
一个接口就要写这么多代码，如果想所有接口都统一处理，有什么更优雅的方式呢？见下面的 `koa2-cors`。
```js
const path = require('path')
const Koa = require('koa')
const koaStatic = require('koa-static')
const bodyParser = require('koa-bodyparser')
const router = require('./router')
const cors = require('koa2-cors')
const app = new Koa()
const port = 9871
app.use(bodyParser())
// 处理静态资源 这里是前端build好之后的目录
app.use(koaStatic(
  path.resolve(__dirname, '../dist')
))
// 处理cors
app.use(cors({
  origin: function (ctx) {
    return 'http://localhost:9099'
  },
  credentials: true,
  allowMethods: ['GET', 'POST', 'DELETE'],
  allowHeaders: ['t', 'Content-Type']
}))
// 路由
app.use(router.routes()).use(router.allowedMethods())
// 监听端口
app.listen(9871)
console.log(`[demo] start-quick is starting at port ${port}`)
前端

fetch(`http://localhost:9871/api/cors?msg=helloCors`, {
  // 需要带上cookie
  credentials: 'include',
  // 这里添加额外的headers来触发非简单请求
  headers: {
    't': 'extra headers'
  }
}).then(res => {
  console.log(res)
})
```
###### 4. 代理
想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，`Nginx` 出场了。

`Nginx` 配置
```js
server{
    // 监听9099端口
    listen 9099;
    // 域名是localhost
    server_name localhost;
    // 凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 
    location ^~ /api {
        proxy_pass http://localhost:9871;
    }    
}
```
前端就不用干什么事情了，除了写接口，也没后端什么事情了

请求的时候直接用回前端这边的域名 `http://localhost:9099`，这就不会跨域，然后 `Nginx` 监听到凡是 `localhost:9099/api` 这个样子的，都转发到真正的服务端地址 `http://localhost:9871`。 
```js
fetch('http://localhost:9099/api/iframePost', {
  method: 'POST',
  headers: {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    msg: 'helloIframePost'
  })
})
```
`Nginx` 转发的方式似乎很方便！但这种使用也是看场景的，如果后端接口是一个公共的 `API`，比如一些公共服务获取天气什么的，前端调用的时候总不能让运维去配置一下 `Nginx`，如果兼容性没问题（`IE 10`或者以上），`CROS` 才是更通用的做法吧。

###### 5. postMessage
`window.postMessage()` 是 `HTML5` 的一个接口，专注实现不同窗口不同页面的跨域通讯。
为了演示方便，我们将 `hosts` 改一下：`127.0.0.1 crossDomain.com`，现在访问域名 `crossDomain.com` 就等于访问 `127.0.0.1`。

这里是 `http://localhost:9099/#/crossDomain`，发消息方
```js
<template>
  <div>
    <button @click="postMessage">给http://crossDomain.com:9099发消息</button>
    <iframe name="crossDomainIframe" src="http://crossdomain.com:9099"></iframe>
  </div>
</template>

<script>
export default {
  mounted () {
    window.addEventListener('message', (e) => {
      // 这里一定要对来源做校验
      if (e.origin === 'http://crossdomain.com:9099') {
        // 来自http://crossdomain.com:9099的结果回复
        console.log(e.data)
      }
    })
  },
  methods: {
    // 向http://crossdomain.com:9099发消息
    postMessage () {
      const iframe = window.frames['crossDomainIframe']
      iframe.postMessage('我是[http://localhost:9099], 麻烦你查一下你那边有没有id为app的Dom', 'http://crossdomain.com:9099')
    }
  }
}
</script>
```

这里是`http://crossdomain.com:9099`，接收消息方

```js
<template>
  <div>
    我是http://crossdomain.com:9099
  </div>
</template>

<script>
export default {
  mounted () {
    window.addEventListener('message', (e) => {
      // 这里一定要对来源做校验
      if (e.origin === 'http://localhost:9099') {
        // http://localhost:9099发来的信息
        console.log(e.data)
        // e.source可以是回信的对象，其实就是http://localhost:9099窗口对象(window)的引用
        // e.origin可以作为targetOrigin
        e.source.postMessage(`我是[http://crossdomain.com:9099]，我知道了兄弟，这就是你想知道的结果：${document.getElementById('app') ? '有id为app的Dom' : '没有id为app的Dom'}`, e.origin);
      }
    })
  }
}
</script>
```

###### 6. document.domain
这种方式只适合主域名相同，但子域名不同的 `iframe` 跨域。
比如主域名是 `http://crossdomain.com:9099`，子域名是 `http://child.crossdomain.com:9099`，这种情况下给两个页面指定一下 `document.domain` 即 `document.domain = crossdomain.com` 就可以访问各自的 `window` 对象了。

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

19.  #### <div id="async_js"></div>请给出异步加载js方案，不少于两种？
默认情况 `javascript` 是同步加载的，也就是 `javascript` 的加载时阻塞的，后面的元素要等待 `javascript` 加载完毕后才能进行再加载，对于一些意义不是很大的 `javascript`，如果放在页头会导致加载很慢的话，是会严重影响用户体验的。
##### 1. defer（只支持IE）
`defer` 属性规定是否对脚本执行进行延迟，直到页面加载为止。
有的 `javascript` 脚本 `document.write` 方法来创建当前的文档内容，不会改变文档的内容

##### 2. async
`async` 属性规定一旦脚本可用，则会异步执行。

##### 3. 创建script，插入到DOM中，加载完毕后callBack，见代码：
复制代码 代码如下:
```js
function loadScript(url, callback) {
    var script = document.createElement_x("script")
    script.type = "text/javascript";
    if (script.readyState) { //IE
        script.onreadystatechange = function () {
            if (script.readyState == "loaded" ||
                script.readyState == "complete") {
                script.onreadystatechange = null;
                callback();
            }
        };
    } else { //Others: Firefox, Safari, Chrome, and Opera
        script.onload = function () {
            callback();
        };
    }
    script.src = url;
    document.body.appendChild(script);
}
```
注释：有多种执行外部脚本的方法：
- async 属性仅适用于外部脚本（只有在使用 src 属性时）。
- 如果 async="async"：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）
- 如果不使用 async 且 defer="defer"：脚本将在页面完成解析时执行
- 如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本

有关链接：[异步加载js的几种方式](https://www.cnblogs.com/1314-/p/6561475.html)

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

20.   #### 多浏览器检测通过什么
- Navigator  对象
- navigator.appName     保存浏览器类型
- navigator.appVersion   存有浏览器的版本信息
- navigator.userAgent     用户代理

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

21.  #### <a id="window_onload"></a> 关于window.onload()了解多少

当文档内容加载完成后，会触发 `window.onload` 方法。

可以为此事件注册事件处理函数，可以把要执行的脚本代码放在事件处理函数中，于是就可以避免获取不到对象的情况。

##### 还需要知道window.onload()的前世今生
看代码
```html
<!DOCTYPE html>
<html>

<head>
    <meta charset=" utf-8">
    <title>window.onload用法</title>
    <style type="text/css">
        #box {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 4px solid red;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-left: -100px;
            margin-right: -100px;
        }
    </style>
    <script type="text/javascript">
        document.getElementById("box").style.backgroundColor = "#ffff00";
    </script>
</head>

<body>
    <div id='box'></div>
</body>

</html>
```
在浏览器中可以看到只是一个红色边框的空圆，但是却没有黄色的背景色

为什么会出现这种情况呢？

是因为 `html` 挂载都是从上往下的顺序，代码中文档放在脚本后面，所以当事件发生时，`box`还没有挂载。都没拿到`box`，那怎么给他填充颜色。

根据从上到下执行的道理，我们可以将js放到后面
```html
<!DOCTYPE html>
<html>

<head>
    <meta charset=" utf-8">
    <title>window.onload用法</title>
    <style type="text/css">
        #box {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 4px solid red;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-left: -100px;
            margin-right: -100px;
        }
    </style>
</head>

<body>
    <div id='box'></div>
</body>

<script type="text/javascript">
    document.getElementById("box").style.backgroundColor = "#ffff00";
</script>

</html>
```
虽然效果是出来了，但是我很不喜欢，我想觉得 `js` 想要自由，不能让他受拘束，所以这时候`window.onload`就应运而生。

`window.onload`方法就可以在文档加载完后，触发事件，并且为此事件注册事件处理函数，于是就避免了对象获取不到的情况。

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset=" utf-8">
    <title>window.onload用法</title>
    <style type="text/css">
        #box {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 4px solid red;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-left: -100px;
            margin-right: -100px;
        }
    </style>
</head>
<script type="text/javascript">
    window.onload = function () {
        document.getElementById("box").style.backgroundColor = "#ffff00";
    }
</script>
<body>
    <div id='box'></div>
</body>
</html>
```

`window.onload`不仅可以绑定匿名函数，还可以绑定非匿名函数
```js
<script type="text/javascript">
    window.onload = function setColor() {
        document.getElementById("box").style.backgroundColor = "#ffff00";
    }
</script>
```
但是如下绑定多个事件，就只能触发最后一个
```js
<script type="text/javascript">
    window.onload = function () {
        document.getElementById("box").style.backgroundColor = "#ffff00"
    }
    window.onload = function () {
        document.getElementById("box").style.height = '400px'
        document.getElementById("box").style.width = '400px'
    }
</script>
```
当浏览器刷新的时候，你会发现圆从小变到大，但是却没有变色。这说明只触发最后一个`window.onload`注册的事件。

可以将两个方法写进一个`window.onload`中，然后都触发一遍
```js
<script type="text/javascript">
    window.onload = function () {
        function setColor1() {
            document.getElementById("box").style.backgroundColor = "#ffff00"
        }

        function setColor2() {
            document.getElementById("box").style.height= '400px'
            document.getElementById("box").style.width= '400px'
        }
        setColor1()
        setColor2()
    }
</script>
```

还可以用`window.addEventListener('load', setColor1, false)`去替换`window.onload`，可以为 `onload` 事件绑定事件处理函数。
```js
<script type="text/javascript">
    window.addEventListener('load', setColor1, false)
    window.addEventListener('load', setColor2, false)

    function setColor1() {
        document.getElementById("box").style.backgroundColor = "#ffff00"
    }

    function setColor2() {
        document.getElementById("box").style.height = '400px'
        document.getElementById("box").style.width = '400px'
    }
</script>
```

但是老版本的 `ie` 浏览器不支持`window.addEventListener`事件模型,如果不支持就使用`window.attachEvent`来实现功能。
```js
<script type="text/javascript">
    if (window.addEventListener) {
        window.addEventListener('load', setColor1, false)
        window.addEventListener('load', setColor2, false)
    } else {
        window.attachEvent('onload', setColor1)
        window.attachEvent('onload', setColor2)
    }

    function setColor1() {
        document.getElementById("box").style.backgroundColor = "#ffff00"
    }

    function setColor2() {
        document.getElementById("box").style.height = '400px'
        document.getElementById("box").style.width = '400px'
    }
</script>
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

22.  #### <a id="generator_auto_next"></a> 如何让generator自动next（不通过next.next.next）

参考自[冴羽](https://github.com/mqyqingfeng/Blog)
##### 单个异步任务
```js
// 单个请求模块
var fetch = require('node-fetch');

function* gen() {
    var url = 'http://navigation.qiufeihong.top/api/v1/superAdmin?limit=3&offset=0&category=recommendationFront-end';
    var result = yield fetch(url);
    // 5.console.log(result);
}

var g = gen()
// 1.console.log(g)
// Object [Generator] {}
var result = g.next()
// 2.console.log(result)
// { value: Promise { <pending> }, done: false }
result.value.then(function (data) {
    // 3.console.log(data)
    // Response {
    //     size: 0,
    //     timeout: 0,
    //     [Symbol(Body internals)]:
    //      { body:
    //         PassThrough {
    //           _readableState: [ReadableState],
    //           readable: true,
    //           _events: [Object],
    //           _eventsCount: 2,
    //           _maxListeners: undefined,
    //           _writableState: [WritableState],
    //           writable: false,
    //           allowHalfOpen: true,
    //           _transformState: [Object] },
    //        disturbed: false,
    //        error: null },
    //     [Symbol(Response internals)]:
    //      { url:
    //         'http://navigation.qiufeihong.top/api/v1/superAdmin?limit=10&offset=0&category=recommendationFront-end',
    //        status: 200,
    //        statusText: 'OK',
    //        headers: Headers { [Symbol(map)]: [Object] },
    //        counter: 0 } }
    return data.json()
}).then(function (data) {
    //4. console.log(data)
    // { data:
    //     [ { _id: '5d5607ddcba39c04be4aa613',
    //         category: 'recommendationFront-end',
    //         name: 'w3schoolstest',
    //         website: 'http://www.w3schools.com/',
    //         describe: 'WEB初学者教程网站',
    //         logo: 'http://chuangzaoshi.com/assets/images/C/w3schools.png',
    //         created_at: '2019-08-16T01:33:17.234Z',
    //         updated_at: '2019-09-06T08:29:02.243Z',
    //         __v: 0 },
    //       { _id: '5d5607ddcba39c04be4aa615',
    //         category: 'recommendationFront-end',
    //         name: 'codepen',
    //         website: 'http://codepen.io/',
    //         describe: '前端炫酷样式技能效果',
    //         logo: 'http://chuangzaoshi.com/assets/images/C/codepen.png',
    //         created_at: '2019-08-16T01:33:17.234Z',
    //         updated_at: '2019-08-16T01:33:17.234Z',
    //         __v: 0 },
    //       { _id: '5d5607ddcba39c04be4aa616',
    //         category: 'recommendationFront-end',
    //         name: 'Fontawesome',
    //         website: 'http://fontawesome.io/',
    //         describe: '全球著名的前端图标字体库',
    //         logo: 'http://chuangzaoshi.com/assets/images/C/fontawesome.png',
    //         created_at: '2019-08-16T01:33:17.234Z',
    //         updated_at: '2019-08-16T01:33:17.234Z',
    //         __v: 0 } ],
    //    total: 21 }
    g.next(data)
})
```
首先执行 `Generator` 函数，获取遍历器对象。

然后使用 next 方法，执行异步任务的第一阶段，即 `fetch(url)`。

注意，由于 `fetch(url)` 会返回一个 `Promise` 对象，所以 `result` 的值为：
```js
 { value: Promise { <pending> }, done: false }
```
最后我们为这个 `Promise` 对象添加一个 `then` 方法，先将其返回的数据格式化`(data.json())`，再调用 `g.next`，将获得的数据传进去，由此可以执行异步任务的第二阶段……

##### 多个异步任务
那如果我们调用了多个接口，使用了多个 yield，照上述情况，我们就要在 then 函数中不断的嵌套下去……

所以我们来看看执行多个异步任务的情况：
```js

// 多个请求模块
var fetch = require('node-fetch');

function* gen() {
    var r1 = yield fetch('http://navigation.qiufeihong.top/api/v1/superAdmin?limit=3&offset=0&category=recommendationFront-end');
    var r2 = yield fetch('http://navigation.qiufeihong.top/api/v1/admin?limit=3&offset=0&category=recommendationFront-end');

    console.log(r1);
    console.log(r2);
}
// 非递归
var g = gen()
var res = g.next()
//1. console.log(res)
// { value: Promise { <pending> }, done: false }
res.value.then(function (data) {
        // 2. console.log(data)        
        // Response {
        //     size: 0,
        //     timeout: 0,
        //     [Symbol(Body internals)]:
        //      { body:
        //         Gunzip {
        //           _readableState: [ReadableState],
        //           readable: true,
        //           _events: [Object],
        //           _eventsCount: 7,
        //           _maxListeners: undefined,
        //           _writableState: [WritableState],
        //           writable: true,
        //           allowHalfOpen: true,
        //           _transformState: [Object],
        //           bytesWritten: 0,
        //           _handle: [Zlib],
        //           _hadError: false,
        //           _writeState: [Uint32Array],
        //           _outBuffer:
        //            <Buffer 7b 22 6c 6f 67 69 6e 22 3a 22 67 69 74 68 75 62 22 2c 22 69 64 22 3a 39 39 31 39 2c 22 6e 6f 64 65 5f 69 64 22 3a 22
        //   4d 44 45 79 4f 6b 39 79 5a 32 46 ... >,
        //           _outOffset: 0,
        //           _level: -1,
        //           _strategy: 0,
        //           _chunkSize: 16384,
        //           _flushFlag: 2,
        //           _scheduledFlushFlag: 0,
        //           _origFlushFlag: 2,
        //           _finishFlushFlag: 2,
        //           _info: undefined },
        //        disturbed: false,
        //        error: null },
        //     [Symbol(Response internals)]:
        //        status: 200,
        //        statusText: 'OK',
        //        headers: Headers { [Symbol(map)]: [Object] },
        //        counter: 0 } }
        return data.json()
    })
    .then(function (data) {
        // 3.    console.log(data)        
        // { data:
        //     [ { _id: '5d5607ddcba39c04be4aa613',
        //         category: 'recommendationFront-end',
        //         name: 'w3schoolstest',
        //         website: 'http://www.w3schools.com/',
        //         describe: 'WEB初学者教程网站',
        //         logo: 'http://chuangzaoshi.com/assets/images/C/w3schools.png',
        //         created_at: '2019-08-16T01:33:17.234Z',
        //         updated_at: '2019-09-06T08:29:02.243Z',
        //         __v: 0 },
        //       { _id: '5d5607ddcba39c04be4aa615',
        //         category: 'recommendationFront-end',
        //         name: 'codepen',
        //         website: 'http://codepen.io/',
        //         describe: '前端炫酷样式技能效果',
        //         logo: 'http://chuangzaoshi.com/assets/images/C/codepen.png',
        //         created_at: '2019-08-16T01:33:17.234Z',
        //         updated_at: '2019-08-16T01:33:17.234Z',
        //         __v: 0 },
        //       { _id: '5d5607ddcba39c04be4aa616',
        //         category: 'recommendationFront-end',
        //         name: 'Fontawesome',
        //         website: 'http://fontawesome.io/',
        //         describe: '全球著名的前端图标字体库',
        //         logo: 'http://chuangzaoshi.com/assets/images/C/fontawesome.png',
        //         created_at: '2019-08-16T01:33:17.234Z',
        //         updated_at: '2019-08-16T01:33:17.234Z',
        //         __v: 0 } ],
        //    total: 21 }
        return g.next(data).value
    })
    .then(function (data) {
        // 4.console.log(data)
        // Response {
        //     size: 0,
        //     timeout: 0,
        //     [Symbol(Body internals)]:
        //      { body:
        //         PassThrough {
        //           _readableState: [ReadableState],
        //           readable: true,
        //           _events: [Object],
        //           _eventsCount: 2,
        //           _maxListeners: undefined,
        //           _writableState: [WritableState],
        //           writable: false,
        //           allowHalfOpen: true,
        //           _transformState: [Object] },
        //        disturbed: false,
        //        error: null },
        //     [Symbol(Response internals)]:
        //      { url:
        //         'http://navigation.qiufeihong.top/api/v1/admin?limit=3&offset=0&category=recommendationFront-end',
        //        status: 200,
        //        statusText: 'OK',
        //        headers: Headers { [Symbol(map)]: [Object] },
        //        counter: 0 } }
        return data.json()
    })
    .then(function (data) {
        // 5.console.log(data)
        // { data: [], total: 0 }
        return g.next(data).value
    })
```
结果返回两个接口的内容

执行函数写的很长

为了避免，可以利用递归
```js
// 递归
function recursion() {
    var g = gen()

    function next(data) {
        var res = g.next(data)
        // 1. console.log(res)
        // { value: Promise { <pending> }, done: false }
        // { value: Promise { <pending> }, done: false }
        // { value: undefined, done: true }
        if (res.done) return
        res.value.then(function (data) {
            // 2.console.log(data)
            // Response {
            //     size: 0,
            //     timeout: 0,
            //     [Symbol(Body internals)]:
            //      { body:
            //         PassThrough {
            //           _readableState: [ReadableState],
            //           readable: true,
            //           _events: [Object],
            //           _eventsCount: 2,
            //           _maxListeners: undefined,
            //           _writableState: [WritableState],
            //           writable: false,
            //           allowHalfOpen: true,
            //           _transformState: [Object] },
            //        disturbed: false,
            //        error: null },
            //     [Symbol(Response internals)]:
            //      { url:
            //         'http://navigation.qiufeihong.top/api/v1/superAdmin?limit=3&offset=0&category=recommendationFront-end',
            //        status: 200,
            //        statusText: 'OK',
            //        headers: Headers { [Symbol(map)]: [Object] },
            //        counter: 0 } }
            //   Response {
            //     size: 0,
            //     timeout: 0,
            //     [Symbol(Body internals)]:
            //      { body:
            //         PassThrough {
            //           _readableState: [ReadableState],
            //           readable: true,
            //           _events: [Object],
            //           _eventsCount: 2,
            //           _maxListeners: undefined,
            //           _writableState: [WritableState],
            //           writable: false,
            //           allowHalfOpen: true,
            //           _transformState: [Object] },
            //        disturbed: false,
            //        error: null },
            //     [Symbol(Response internals)]:
            //      { url:
            //         'http://navigation.qiufeihong.top/api/v1/admin?limit=3&offset=0&category=recommendationFront-end',
            //        status: 200,
            //        statusText: 'OK',
            //        headers: Headers { [Symbol(map)]: [Object] },
            //        counter: 0 } }
            return data.json()
        }).then(function (data) {
            // 3.console.log(data)
            // { data:
            //     [ { _id: '5d5607ddcba39c04be4aa613',
            //         category: 'recommendationFront-end',
            //         name: 'w3schoolstest',
            //         website: 'http://www.w3schools.com/',
            //         describe: 'WEB初学者教程网站',
            //         logo: 'http://chuangzaoshi.com/assets/images/C/w3schools.png',
            //         created_at: '2019-08-16T01:33:17.234Z',
            //         updated_at: '2019-09-06T08:29:02.243Z',
            //         __v: 0 },
            //       { _id: '5d5607ddcba39c04be4aa615',
            //         category: 'recommendationFront-end',
            //         name: 'codepen',
            //         website: 'http://codepen.io/',
            //         describe: '前端炫酷样式技能效果',
            //         logo: 'http://chuangzaoshi.com/assets/images/C/codepen.png',
            //         created_at: '2019-08-16T01:33:17.234Z',
            //         updated_at: '2019-08-16T01:33:17.234Z',
            //         __v: 0 },
            //       { _id: '5d5607ddcba39c04be4aa616',
            //         category: 'recommendationFront-end',
            //         name: 'Fontawesome',
            //         website: 'http://fontawesome.io/',
            //         describe: '全球著名的前端图标字体库',
            //         logo: 'http://chuangzaoshi.com/assets/images/C/fontawesome.png',
            //         created_at: '2019-08-16T01:33:17.234Z',
            //         updated_at: '2019-08-16T01:33:17.234Z',
            //         __v: 0 } ],
            //    total: 21 }
            //  { data: [], total: 0 }
            next(data)
        })
    }
    next()
}
recursion()
```
其中的关键就是 `yield` 的时候返回一个 `Promise` 对象，给这个 `Promise` 对象添加 `then` 方法，当异步操作成功时执行 `then` 中的 `onFullfilled` 函数，`onFullfilled` 函数中又去执行 `g.next`，从而让 `Generator` 继续执行，然后再返回一个 `Promise`，再在成功时执行 `g.next`，然后再返回……

##### 启动器函数
在 `recursion` 这个启动器函数中，我们在 `then` 函数中将数据格式化 `data.json()`，但在更广泛的情况下，比如 `yield` 直接跟一个 `Promise`，而非一个 `fetch` 函数返回的 `Promise`，因为没有 `json` 方法，代码就会报错。所以为了更具备通用性，连同这个例子和启动器，我们修改为：
```js

var fetch = require('node-fetch');

function* gen() {
    var r1 = yield fetch('http://navigation.qiufeihong.top/api/v1/superAdmin?limit=3&offset=0&category=recommendationFront-end');
    var j1 = yield r1.json()
    var r2 = yield fetch('http://navigation.qiufeihong.top/api/v1/admin?limit=3&offset=0&category=recommendationFront-end');
    var j2 = yield r2.json()
    // console.log(j1);
    // console.log(j2);
}
// 递归
function recursion() {
    var g = gen()

    function next(data) {
        let res = g.next(data)
        // 1.  console.log(res)
        // { value: Promise { <pending> }, done: false }
        // { value: Promise { <pending> }, done: false }
        // { value: Promise { <pending> }, done: false }
        // { value: Promise { <pending> }, done: false }
        // { value: undefined, done: true }
        if (res.done) return
        res.value.then(function (data) {
        //    2. console.log(data)
        // Response {
        //     size: 0,
        //     timeout: 0,
        //     [Symbol(Body internals)]:
        //      { body:
        //         PassThrough {
        //           _readableState: [ReadableState],
        //           readable: true,
        //           _events: [Object],
        //           _eventsCount: 2,
        //           _maxListeners: undefined,
        //           _writableState: [WritableState],
        //           writable: false,
        //           allowHalfOpen: true,
        //           _transformState: [Object] },
        //        disturbed: false,
        //        error: null },
        //     [Symbol(Response internals)]:
        //      { url:
        //         'http://navigation.qiufeihong.top/api/v1/superAdmin?limit=3&offset=0&category=recommendationFront-end',
        //        status: 200,
        //        statusText: 'OK',
        //        headers: Headers { [Symbol(map)]: [Object] },
        //        counter: 0 } }
        //   { data:
        //      [ { _id: '5d5607ddcba39c04be4aa613',
        //          category: 'recommendationFront-end',
        //          name: 'w3schoolstest',
        //          website: 'http://www.w3schools.com/',
        //          describe: 'WEB初学者教程网站',
        //          logo: 'http://chuangzaoshi.com/assets/images/C/w3schools.png',
        //          created_at: '2019-08-16T01:33:17.234Z',
        //          updated_at: '2019-09-06T08:29:02.243Z',
        //          __v: 0 },
        //        { _id: '5d5607ddcba39c04be4aa615',
        //          category: 'recommendationFront-end',
        //          name: 'codepen',
        //          website: 'http://codepen.io/',
        //          describe: '前端炫酷样式技能效果',
        //          logo: 'http://chuangzaoshi.com/assets/images/C/codepen.png',
        //          created_at: '2019-08-16T01:33:17.234Z',
        //          updated_at: '2019-08-16T01:33:17.234Z',
        //          __v: 0 },
        //        { _id: '5d5607ddcba39c04be4aa616',
        //          category: 'recommendationFront-end',
        //          name: 'Fontawesome',
        //          website: 'http://fontawesome.io/',
        //          describe: '全球著名的前端图标字体库',
        //          logo: 'http://chuangzaoshi.com/assets/images/C/fontawesome.png',
        //          created_at: '2019-08-16T01:33:17.234Z',
        //          updated_at: '2019-08-16T01:33:17.234Z',
        //          __v: 0 } ],
        //     total: 21 }
        //   Response {
        //     size: 0,
        //     timeout: 0,
        //     [Symbol(Body internals)]:
        //      { body:
        //         PassThrough {
        //           _readableState: [ReadableState],
        //           readable: true,
        //           _events: [Object],
        //           _eventsCount: 2,
        //           _maxListeners: undefined,
        //           _writableState: [WritableState],
        //           writable: false,
        //           allowHalfOpen: true,
        //           _transformState: [Object] },
        //        disturbed: false,
        //        error: null },
        //     [Symbol(Response internals)]:
        //      { url:
        //         'http://navigation.qiufeihong.top/api/v1/admin?limit=3&offset=0&category=recommendationFront-end',
        //        status: 200,
        //        statusText: 'OK',
        //        headers: Headers { [Symbol(map)]: [Object] },
        //        counter: 0 } }
        //   { data: [], total: 0 }
            next(data)
        })
    }
    next()
}
recursion()
```
只要 `yield` 后跟着一个 `Promise` 对象，我们就可以利用这个 `recursion` 函数将 `Generator` 函数自动执行。

##### 启动器函数
由此可以看到 `Generator` 函数的自动执行需要一种机制，即当异步操作有了结果，能够自动交回执行权。

>可以通过promise获得
>>Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。

##### co
如果我们再将这个启动器函数写的完善一些，我们就相当于写了一个 `co`

而 `co` 是什么？ `co` 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 `Generator` 函数的自动执行。

如果直接使用 `co` 模块，上面的例子可以简写成:

```js
// yield 后是一个 Promise
var fetch = require('node-fetch');
var co = require('co');
 
function* gen() {
    var r1 = yield fetch('http://navigation.qiufeihong.top/api/v1/superAdmin?limit=3&offset=0&category=recommendationFront-end');
    var j1 = yield r1.json()
    var r2 = yield fetch('http://navigation.qiufeihong.top/api/v1/admin?limit=3&offset=0&category=recommendationFront-end');
    var j2 = yield r2.json()
    console.log(j1);
    console.log(j2);
    // { data:
    //     [ { _id: '5d5607ddcba39c04be4aa613',
    //         category: 'recommendationFront-end',
    //         name: 'w3schoolstest',
    //         website: 'http://www.w3schools.com/',
    //         describe: 'WEB初学者教程网站',
    //         logo: 'http://chuangzaoshi.com/assets/images/C/w3schools.png',
    //         created_at: '2019-08-16T01:33:17.234Z',
    //         updated_at: '2019-09-06T08:29:02.243Z',
    //         __v: 0 },
    //       { _id: '5d5607ddcba39c04be4aa615',
    //         category: 'recommendationFront-end',
    //         name: 'codepen',
    //         website: 'http://codepen.io/',
    //         describe: '前端炫酷样式技能效果',
    //         logo: 'http://chuangzaoshi.com/assets/images/C/codepen.png',
    //         created_at: '2019-08-16T01:33:17.234Z',
    //         updated_at: '2019-08-16T01:33:17.234Z',
    //         __v: 0 },
    //       { _id: '5d5607ddcba39c04be4aa616',
    //         category: 'recommendationFront-end',
    //         name: 'Fontawesome',
    //         website: 'http://fontawesome.io/',
    //         describe: '全球著名的前端图标字体库',
    //         logo: 'http://chuangzaoshi.com/assets/images/C/fontawesome.png',
    //         created_at: '2019-08-16T01:33:17.234Z',
    //         updated_at: '2019-08-16T01:33:17.234Z',
    //         __v: 0 } ],
    //    total: 21 }
    //  { data: [], total: 0 }
}
 
co(gen);
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

23. #### promise原理

##### 什么是promise

promise的中文意思是承诺，

并且会回复三种状态，分别是：等待中（pending）、完成了 （resolved）和拒绝了（rejected）

既然是承诺，那就得一言既出驷马难追。
所以`promise`一旦从等待状态变成为其他状态就永远不能更改状态了
```js
new Promise((resolve, reject) => {
  resolve('success')
  reject('reject')// 无效
})
```
pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。

因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。

不要和惰性求值混淆： 有一些语言中有惰性求值和延时计算的特性，它们也被称为“promises”，例如Scheme.Javascript中的promise代表一种已经发生的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的"箭头方法":  f = () =>表达式 创建惰性求值的表达式，使用 f() 求值。

注意： 如果一个promise对象处在fulfilled或rejected状态而不是pending状态，那么它也可以被称为settled状态。你可能也会听到一个术语resolved ，它表示promise对象处于settled状态。

[](https://mdn.mozillademos.org/files/8633/promises.png)

###### 参数
executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。
###### 属性
Promise.length
length属性，其值总是为 1 (构造器参数的数目).
Promise.prototype
表示 Promise 构造器的原型.
###### 方法
- Promise.all(iterable)
这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。`Promise.all`方法常被用于处理多个`promise`对象的状态集合。
- Promise.race(iterable)  
当`iterable`参数里的任意一个子`promise`被成功或失败后，父`promise`马上也会用子`promise`的成功返回值或失败详情作为参数调用父`promise`绑定的相应句柄，并返回该`promise`对象。
- Promise.reject(reason)
返回一个状态为失败的`Promise`对象，并将给定的失败信息传递给对应的处理方法
- Promise.resolve(value)
返回一个状态由给定`value`决定的`Promise`对象。如果该值是`thenable`(即，带有`then`方法的对象)，返回的`Promise`对象的最终状态由`then`方法执行决定；否则的话(该`value`为空，基本类型或者不带`then`方法的对象),返回的`Promise`对象状态为`fulfilled`，并且将该`value`传递给对应的`then`方法。通常而言，如果你不知道一个值是否是`Promise`对象，使用`Promise.resolve(value)` 来返回一个`Promise`对象,这样就能将该`value`以`Promise`对象形式使用。
###### 基本用法
```js
new Promise( function(resolve, reject) {...} /* executor */  );
```
Promise 对象是由关键字 new 及其构造函数来创建的。该构造函数会把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。
```js
const myFirstPromise = new Promise((resolve, reject) => {
  // ?做一些异步操作，最终会调用下面两者之一:
  //
  //   resolve(someValue); // fulfilled
  // ?或
  //   reject("failure reason"); // rejected
});
```

当我们在构造 `Promise` 的时候，构造函数内部的代码是立即执行的

```js
new Promise((resolve, reject) => {
  console.log('new Promise')
  resolve('success')
})
console.log('finish')
// new Promise -> finish
```
`Promise` 实现了链式调用，也就是说每次调用 `then` 之后返回的都是一个 `Promise`，
并且是一个全新的 `Promise`，原因也是因为状态不可变。
如果你在 `then` 中 使用了 `return`，那么 `return` 的值会被 `Promise.resolve()` 包装
前一个`then`中的`return`的值就是后一个`then`的返回值。
```js
Promise.resolve('hello world')
  .then(res => {
    console.log(res) // => hello world
    return 'hello javascript' // 包装成 Promise.resolve(hello javascript)
  })
  .then(res => {
    console.log(res) // => hello javascript
  })
```
当然了，`Promise` 也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：
```js
ajax(url)
  .then(res => {
      console.log(res)
      return ajax(url1)
  }).then(res => {
      console.log(res)
      return ajax(url2)
  }).then(res => console.log(res))
```

##### 高级示例
本例展示了 Promise 的一些机制。 testPromise() 方法在每次点击 <button> 按钮时被调用，该方法会创建一个promise 对象，使用 window.setTimeout() 让Promise等待 10-12 秒不等的时间来填充数据（通过Math.random()方法）。

Promise 的值的填充过程都被日志记录（logged）下来，这些日志信息展示了方法中的同步代码和异步代码是如何通过Promise完成解耦的。
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <button id="bth">开始</button>
    <div id="container"></textarea>
</body>
<script>
    document.getElementById('bth').addEventListener('click', testPromise)
    var promiseCount = 0;

    function testPromise() {
        let thisPromiseCount = ++promiseCount;

        let container = document.getElementById('container');
        // 1.
        container.insertAdjacentHTML('beforeend', `${thisPromiseCount}. 开始 (<small>同步代码开始</small>)<br/>`);
        // insertAdjacentHTML() 将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。
        // 位置名称的可视化：节
        // <!-- beforebegin --> 
        // <p> 
        // <!-- afterbegin -->
        // foo
        // <!-- beforeend -->
        // </p>
        // <!-- afterend -->
        // 新构建一个 Promise 实例：使用Promise实现每过一段时间给计数器加一的过程，每段时间间隔为1~3秒不等
        let p1 = new Promise(
            // resolver 函数在 Promise 成功或失败时都可能被调用
            (resolve, reject) => {
                // 2.
                container.insertAdjacentHTML('beforeend',
                    `${thisPromiseCount}. Promise 开始 (<small>异步代码开始</small>)<br/>`);
                // 创建一个异步调用
                window.setTimeout(
                    function () {
                        // 填充 Promise
                        resolve(thisPromiseCount);
                    }, Math.random() * 2000 + 10000);
            }
        );

        // Promise 不论成功或失败都会调用 then
        // catch() 只有当 promise 失败时才会调用
        p1.then(
                // 4
                // 记录填充值
                function (val) {
                    container.insertAdjacentHTML('beforeend', `${val}. Promise 已填充完毕 (<small>异步代码结束</small>)<br/>`);
                })
            .catch(
                // 记录失败原因
                (reason) => {
                    console.log(`处理失败的 promise ${reason}`);
                });
        // 3
        container.insertAdjacentHTML('beforeend', `${thisPromiseCount}. Promise made (<small>同步代码结束</small>)<br/>`);
    }
</script>

</html>
```
按一次结果
```
1. 开始 (同步代码开始)
1. Promise 开始 (异步代码开始)
1. Promise made (同步代码结束)
1. Promise 已填充完毕 (异步代码结束)
```
连续多次
```
2. 开始 (同步代码开始)
2. Promise 开始 (异步代码开始)
2. Promise made (同步代码结束)
3. 开始 (同步代码开始)
3. Promise 开始 (异步代码开始)
3. Promise made (同步代码结束)
4. 开始 (同步代码开始)
4. Promise 开始 (异步代码开始)
4. Promise made (同步代码结束)
5. 开始 (同步代码开始)
5. Promise 开始 (异步代码开始)
5. Promise made (同步代码结束)
6. 开始 (同步代码开始)
6. Promise 开始 (异步代码开始)
6. Promise made (同步代码结束)
7. 开始 (同步代码开始)
7. Promise 开始 (异步代码开始)
7. Promise made (同步代码结束)
8. 开始 (同步代码开始)
8. Promise 开始 (异步代码开始)
8. Promise made (同步代码结束)
9. 开始 (同步代码开始)
9. Promise 开始 (异步代码开始)
9. Promise made (同步代码结束)
10. 开始 (同步代码开始)
10. Promise 开始 (异步代码开始)
10. Promise made (同步代码结束)
3. Promise 已填充完毕 (异步代码结束)
4. Promise 已填充完毕 (异步代码结束)
5. Promise 已填充完毕 (异步代码结束)
10. Promise 已填充完毕 (异步代码结束)
2. Promise 已填充完毕 (异步代码结束)
7. Promise 已填充完毕 (异步代码结束)
8. Promise 已填充完毕 (异步代码结束)
6. Promise 已填充完毕 (异步代码结束)
9. Promise 已填充完毕 (异步代码结束)
```


##### [promise的实现原理](https://www.jianshu.com/p/43de678e918a)
 ```js 
 // 判断变量否为function
  const isFunction = variable => typeof variable === 'function'
  // 定义Promise的三种状态常量
  const PENDING = 'PENDING'
  const FULFILLED = 'FULFILLED'
  const REJECTED = 'REJECTED'

  class MyPromise {
    constructor (handle) {
      if (!isFunction(handle)) {
        throw new Error('MyPromise must accept a function as a parameter')
      }
      // 添加状态
      this._status = PENDING
      // 添加状态
      this._value = undefined
      // 添加成功回调函数队列
      this._fulfilledQueues = []
      // 添加失败回调函数队列
      this._rejectedQueues = []
      // 执行handle
      try {
        handle(this._resolve.bind(this), this._reject.bind(this)) 
      } catch (err) {
        this._reject(err)
      }
    }
    // 添加resovle时执行的函数
    _resolve (val) {
      const run = () => {
        if (this._status !== PENDING) return
        this._status = FULFILLED
        // 依次执行成功队列中的函数，并清空队列
        const runFulfilled = (value) => {
          let cb;
          while (cb = this._fulfilledQueues.shift()) {
            cb(value)
          }
        }
        // 依次执行失败队列中的函数，并清空队列
        const runRejected = (error) => {
          let cb;
          while (cb = this._rejectedQueues.shift()) {
            cb(error)
          }
        }
        /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
          当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
        */
        if (val instanceof MyPromise) {
          val.then(value => {
            this._value = value
            runFulfilled(value)
          }, err => {
            this._value = err
            runRejected(err)
          })
        } else {
          this._value = val
          runFulfilled(val)
        }
      }
      // 为了支持同步的Promise，这里采用异步调用
      setTimeout(run, 0)
    }
    // 添加reject时执行的函数
    _reject (err) { 
      if (this._status !== PENDING) return
      // 依次执行失败队列中的函数，并清空队列
      const run = () => {
        this._status = REJECTED
        this._value = err
        let cb;
        while (cb = this._rejectedQueues.shift()) {
          cb(err)
        }
      }
      // 为了支持同步的Promise，这里采用异步调用
      setTimeout(run, 0)
    }
    // 添加then方法
    then (onFulfilled, onRejected) {
      const { _value, _status } = this
      // 返回一个新的Promise对象
      return new MyPromise((onFulfilledNext, onRejectedNext) => {
        // 封装一个成功时执行的函数
        let fulfilled = value => {
          try {
            if (!isFunction(onFulfilled)) {
              onFulfilledNext(value)
            } else {
              let res =  onFulfilled(value);
              if (res instanceof MyPromise) {
                // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                res.then(onFulfilledNext, onRejectedNext)
              } else {
                //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                onFulfilledNext(res)
              }
            }
          } catch (err) {
            // 如果函数执行出错，新的Promise对象的状态为失败
            onRejectedNext(err)
          }
        }
        // 封装一个失败时执行的函数
        let rejected = error => {
          try {
            if (!isFunction(onRejected)) {
              onRejectedNext(error)
            } else {
                let res = onRejected(error);
                if (res instanceof MyPromise) {
                  // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
                  res.then(onFulfilledNext, onRejectedNext)
                } else {
                  //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
                  onFulfilledNext(res)
                }
            }
          } catch (err) {
            // 如果函数执行出错，新的Promise对象的状态为失败
            onRejectedNext(err)
          }
        }
        switch (_status) {
          // 当状态为pending时，将then方法回调函数加入执行队列等待执行
          case PENDING:
            this._fulfilledQueues.push(fulfilled)
            this._rejectedQueues.push(rejected)
            break
          // 当状态已经改变时，立即执行对应的回调函数
          case FULFILLED:
            fulfilled(_value)
            break
          case REJECTED:
            rejected(_value)
            break
        }
      })
    }
    // 添加catch方法
    catch (onRejected) {
      return this.then(undefined, onRejected)
    }
    // 添加静态resolve方法
    static resolve (value) {
      // 如果参数是MyPromise实例，直接返回这个实例
      if (value instanceof MyPromise) return value
      return new MyPromise(resolve => resolve(value))
    }
    // 添加静态reject方法
    static reject (value) {
      return new MyPromise((resolve ,reject) => reject(value))
    }
    // 添加静态all方法
    static all (list) {
      return new MyPromise((resolve, reject) => {
        /**
         * 返回值的集合
         */
        let values = []
        let count = 0
        for (let [i, p] of list.entries()) {
          // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
          this.resolve(p).then(res => {
            values[i] = res
            count++
            // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
            if (count === list.length) resolve(values)
          }, err => {
            // 有一个被rejected时返回的MyPromise状态就变成rejected
            reject(err)
          })
        }
      })
    }
    // 添加静态race方法
    static race (list) {
      return new MyPromise((resolve, reject) => {
        for (let p of list) {
          // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
          this.resolve(p).then(res => {
            resolve(res)
          }, err => {
            reject(err)
          })
        }
      })
    }
    finally (cb) {
      return this.then(
        value  => MyPromise.resolve(cb()).then(() => value),
        reason => MyPromise.resolve(cb()).then(() => { throw reason })
      );
    }
  }
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

24. #### 变量提升

```javascript
function sayHi() {
  console.log(name);
  console.log(age);
  var name = "Lydia";
  let age = 21;
}

sayHi();

A: Lydia and undefined
B: Lydia and ReferenceError
C: ReferenceError and 21
D: undefined and ReferenceError
```
<details><summary><b>答案</b></summary>

D

在函数中，我们首先用关键词`var`声明`name`变量。这意味着这个变量提升（内存空间是在创建阶段被设置的），其默认值是`undefined`,直到我们真正到达定义变量的那一行。我们还没有在试图记录name变量的行上定义变量，所以它仍然保留`undefined`的值。

用`let` 和`const`关键词定义的变量被提升，但是不像`var`，不会获得初始值。在我们定义（初始化）他们之前，他们是不被接受的。这被叫做“暂时性死区”。在他们被声明之前,我们试图去获得这个变量，javascript是会抛出`ReferenceError`。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

25. ####  let和const的闭包

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
A: 0 1 2 and 0 1 2
B: 0 1 2 and 3 3 3
C: 3 3 3 and 0 1 2
```
<details><summary><b>答案</b></summary>

C

因为在javascript中的事件队列，在循环执行后，`setTimeout`的回调才被调用。变量`i`在第一次循环中用`var`关键词被定义。在循环中，我们每次用一元操作符`++`按步长1来递增`i`。在调用`setTimeout`回调函数时，`i`在第一个例子中就等于`3`。

在第二个循环中，变量`i`被关键词`let`定义：变量被关键词`let`和`const`定义会产生闭包（块局限于`{}`）。在每个迭代中，`i`将有一个新的值，并且在循环内，每个值都是有范围的。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)


26. #### this的指向

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius
};

shape.diameter();
shape.perimeter();
A: 20 and 62.83185307179586
B: 20 and NaN
C: 20 and 63
D: NaN and 63
```
<details><summary><b>答案</b></summary>

B

注意，`diameter` 的值是一个正则函数，而`perimeter `的值是一个箭头函数。对于箭头函数，this关键字指的是它当前周围的作用域，这与常规函数不同!这意味着当我们调用`perimeter`时，它不是指向`shape`对象，而是指向它的周围范围(例如`window `)。该对象上没有值`radius`，它返回未定义的值。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

27. #### 哪个是true

```javascript
const bird = {
  size: "small"
};

const mouse = {
  name: "Mickey",
  small: true
};
A: mouse.bird.size is not valid
B: mouse[bird.size] is not valid
C: mouse[bird["size"]] is not valid
D: All of them are valid
```
<details><summary><b>答案</b></summary>

A

在JavaScript中，所有对象键都是字符串(除非它是符号)。尽管我们可能不会将它们作为字符串输入。

JavaScript解释(或取消框)语句。当我们使用方括号表示法时，它会看到第一个左方括号[并继续下去，直到找到右方括号]。只有到那时，它才会对语句求值。

mouse.bird.size 没有值 undefined

mouse[bird.size] = true

mouse[bird["size"]] = true
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

28. #### 对象赋值之内存地址不变

```javascript
let c = { greeting: "Hey!" };
let d;

d = c;
c.greeting = "Hello";
console.log(d.greeting);
A: Hello
B: Hey
C: undefined
D: ReferenceError
E: TypeError
```
<details><summary><b>答案</b></summary>

A

在JavaScript中，所有对象在彼此相等时通过引用进行交互。首先，变量c持有对象的值。d等于c，就是d和c共享一个引用位置。当更改一个对象时，将更改所有对象
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

29. #### <a id="new_number"></a> new Number、==和===

```javascript
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
A: true false true
B: false false true
C: true false false
D: false true true
```
<details><summary><b>答案</b></summary>

C

new Number()是一个内置函数构造函数。虽然它看起来像一个数字，但它并不是一个真正的数字:它有许多额外的功能，是一个对象。当我们使用==操作符时，它只检查它是否具有相同的值。它们的值都是3，所以返回true。但是，当我们使用===操作符时，值和类型应该是相同的。它不是:new Number()不是一个数字，而是一个对象。返回false。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)


30. #### 静态方法

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = "green" } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: "purple" });
freddie.colorChange("orange");
A: orange
B: purple
C: green
D: TypeError
```
<details><summary><b>答案</b></summary>

D

colorChange函数是静态的。静态方法被设计为仅存在于创建它们的构造函数上，并且不能传递给任何子方法。由于freddie是一个子函数，因此函数不会传递下去，并且在freddie实例上不可用:会抛出一个类型错误。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)


31. #### 输出什么7

```javascript
let greeting;
greetign = {}; // Typo!
console.log(greetign);
A: {}
B: ReferenceError: greetign is not defined
C: undefined
```
<details><summary><b>答案</b></summary>

A

它记录对象，因为我们刚刚在全局对象上创建了一个空对象!当我们把问候语拼错为greetign时，JS解释器实际上把它看作是全局的。greetign ={}(或window)。浏览器中的greetign ={})。为了避免这种情况，我们可以使用“use strict”。这确保您在将变量设置为任何值之前声明了该变量。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

32. #### 当我们做这些会发生什么

```javascript
function bark() {
  console.log("Woof!");
}

bark.animal = "dog";
A: Nothing, this is totally fine!
B: SyntaxError. You cannot add properties to a function this way.
C: undefined
D: ReferenceError
```
<details><summary><b>答案</b></summary>

A

这在JavaScript中是可能的，因为函数是对象!(除了基本类型之外的所有东西都是对象)
函数是对象的一种特殊类型。您自己编写的代码并不是实际的函数。函数是一个带有属性的对象。此属性是可调用的。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

33. #### 输出什么8

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person("Lydia", "Hallie");
Person.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};

console.log(member.getFullName());
A: TypeError
B: SyntaxError
C: Lydia Hallie
D: undefined undefined
```
<details><summary><b>答案</b></summary>

C
不能像添加常规对象那样向构造函数添加属性。如果您想一次向所有对象添加一个特性，则必须使用原型。在这种情况下，
```js
Person.prototype.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};
```
将使member.getFullName()起作用。为什么这是有益的?假设我们将这个方法添加到构造函数本身。也许不是每个Person实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是它们都可以访问它!
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

34. #### 输出什么9

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}

const lydia = new Person('Lydia', 'Hallie')
const sarah = Person('Sarah', 'Smith')

console.log(lydia)
console.log(sarah)
A: Person {firstName: "Lydia", lastName: "Hallie"} and undefined
B: Person {firstName: "Lydia", lastName: "Hallie"} and Person {firstName: "Sarah", lastName: "Smith"}
C: Person {firstName: "Lydia", lastName: "Hallie"} and {}
D:Person {firstName: "Lydia", lastName: "Hallie"} and ReferenceError
```
<details><summary><b>答案</b></summary>

A

对于 sarah，我们没有使用 new 关键字。当使用 new 时，this 引用我们创建的空对象。当未使用 new 时，this 引用的是全局对象（global object）。

我们说 this.firstName 等于 "Sarah"，并且 this.lastName 等于 "Smith"。实际上我们做的是，定义了 global.firstName = 'Sarah' 和 global.lastName = 'Smith'。而 sarah 本身是 undefined。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

35. ####  事件传播的三个阶段是什么

```javascript
A: Target > Capturing > Bubbling
B: Bubbling > Target > Capturing
C: Target > Bubbling > Capturing
D: Capturing > Target > Bubbling
```
<details><summary><b>答案</b></summary>

D

在捕获（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到目标（target）元素后，冒泡（bubbling）才开始。
事件捕获：当使用事件捕获时，父级元素先触发，子元素后触发
事件冒泡：当使用事件冒泡时，子级元素先触发，父元素后触发
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

36. ####  输出什么10

```javascript
function sum(a, b) {
  return a + b
}

sum(1, '2')
A: NaN
B: TypeError
C: "12"
D: 3
```
<details><summary><b>答案</b></summary>

C

JavaScript 是一种动态类型语言：我们不指定某些变量的类型。值可以在你不知道的情况下自动转换成另一种类型，这种类型称为隐式类型转换。
在本例中，JavaScript 将数字 1 转换为字符串，以便函数有意义并返回一个值。在数字类型（1）和字符串类型（'2'）相加时，该数字被视为字符串。我们可以连接字符串，比如 "Hello" + "World"，这里发生的是 "1" + "2"，它返回 "12"。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

37. ####  输出什么11

```javascript
let number = 0
console.log(number++)
console.log(++number)
console.log(number)
A: 1 1 2
B: 1 2 2
C: 0 2 2
D: 0 1 2
```
<details><summary><b>答案</b></summary>

C

一元后自增运算符 ++：

返回值（返回 0）
值自增（number 现在是 1）
一元前自增运算符 ++：

值自增（number 现在是 2）
返回值（返回 2）
结果是 0 2 2.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

38. #### 输出什么12
```javascript
function getPersonInfo(one, two, three) {
  console.log(one)
  console.log(two)
  console.log(three)
}

const person = 'Lydia'
const age = 21

getPersonInfo`${person} is ${age} years old`
A: "Lydia" 21 ["", " is ", " years old"]
B: ["", " is ", " years old"] "Lydia" 21
C: "Lydia" ["", " is ", " years old"] 21
```
<details><summary><b>答案</b></summary>

答案: B

如果使用标记模板字面量，第一个参数的值总是包含字符串的数组。其余的参数获取的是传递的表达式的值！
模板字符串使用反引号 (` `) 来代替普通字符串中的用双引号和单引号。

##### 原始字符串
在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串，而不经过特殊字符的替换。
```js
function tag(strings) {
  console.log(strings.raw[0]);
}

tag`string text line 1 \n string text line 2`;
// logs "string text line 1 \n string text line 2" ,
// including the two characters '\' and 'n'
```
另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。
```js
var str = String.raw`Hi\n${2+3}!`;
// "Hi\n5!"

str.length;
// 6

str.split('').join(',');
// "H,i,\,n,5,!"
```

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

39. ####  对象判断相等

```javascript
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!')
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.')
  } else {
    console.log(`Hmm.. You don't have an age I guess`)
  }
}

checkAge({ age: 18 })
A: You are an adult!
B: You are still an adult.
C: Hmm.. You don't have an age I guess
```
<details><summary><b>答案</b></summary>

答案: C
在测试相等性时，基本类型通过它们的值（value）进行比较，而对象通过它们的引用（reference）进行比较。JavaScript 检查对象是否具有对内存中相同位置的引用。

题目中我们正在比较的两个对象不是同一个引用：作为参数传递的对象引用的内存位置，与用于判断相等的对象所引用的内存位置并不同。

这也是 { age: 18 } === { age: 18 } 和 { age: 18 } == { age: 18 } 都返回 false 的原因。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

40. ####  输出什么14

```javascript
function getAge(...args) {
  console.log(typeof args)
}

getAge(21)
A: "number"
B: "array"
C: "object"
D: "NaN"
```
<details><summary><b>答案</b></summary>

答案: C
扩展运算符（...args）会返回实参组成的数组。而数组是对象，因此 typeof args 返回 "object"。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

41. ####  所有对象都有原型

```javascript
A: true
B: false
```
<details><summary><b>答案</b></summary>

答案: B
除了基础对象（base object），所有对象都有原型。基本对象可以访问一些方法和属性，如.tostring。这就是为什么可以使用内置的javascript方法。所有这些方法在原型上都是可用的。虽然javascript不能直接在对象上找到这些方法，但javascript会沿着原型链找到他们，以便使用。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

42. ####  输出什么15

```javascript
function getAge() {
  'use strict'
  age = 21
  console.log(age)
}

getAge()
A: 21
B: undefined
C: ReferenceError
D: TypeError
```
<details><summary><b>答案</b></summary>

答案: C

使用 "use strict"，你可以确保不会意外地声明全局变量。我们从来没有声明变量 age，因为我们使用 "use strict"，它将抛出一个引用错误。如果我们不使用 "use strict"，它就会工作，因为属性 age 会被添加到全局对象中了。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

43. #### 输出什么16

```javascript
const sum = eval('10*10+5')
A: 105
B: "105"
C: TypeError
D: "10*10+5"

```
<details><summary><b>答案</b></summary>

答案: A

代码以字符串形式传递进来，eval 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 10 * 10 + 5。这将返回数字 105。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

44. #### session可访问多长时间

```javascript
sessionStorage.setItem('session', 123)
A: 永远，数据不会丢失。
B: 当用户关掉标签页时。
C: 当用户关掉整个浏览器，而不只是关掉标签页。
D: 当用户关闭电脑时。

```
<details><summary><b>答案</b></summary>

答案: B

关闭 tab 标签页 后，sessionStorage 存储的数据才会删除。

如果使用 localStorage，那么数据将永远在那里，除非调用了 localStorage.clear()。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

45. #### 输出什么17

```javascript
var num = 8
var num = 10

console.log(num)
A: 8
B: 10
C: SyntaxError
D: ReferenceError

```
<details><summary><b>答案</b></summary>

答案: B

使用 var 关键字，你可以用相同的名称声明多个变量。然后变量将保存最新的值。

你不能使用 let 或 const 来实现这一点，因为它们是块作用域的。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

46. ####  输出什么18

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' }
const set = new Set([1, 2, 3, 4, 5])

obj.hasOwnProperty('1')
obj.hasOwnProperty(1)
set.has('1')
set.has(1)
A: false true false true
B: false true true true
C: true true false true
D: true true true true
```
<details><summary><b>答案</b></summary>

答案: C

所有对象的键（不包括 Symbol）在底层都是字符串，即使你自己没有将其作为字符串输入。这就是为什么 obj.hasOwnProperty('1') 也返回 true。

对于集合，它不是这样工作的。在我们的集合中没有 '1'：set.has('1') 返回 false。它有数字类型为 1，set.has(1) 返回 true。

1. 对象object的key只可以是字符串
2. 集合set的key可以有数字类型
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

47. #### 输出什么19

```javascript
const obj = { a: 'one', b: 'two', a: 'three' }
console.log(obj)
```

- A: `{ a: "one", b: "two" }`
- B: `{ b: "two", a: "three" }`
- C: `{ a: "three", b: "two" }`
- D: `SyntaxError`

<details><summary><b>答案</b></summary>
<p>

 答案: C

如果你有两个名称相同的键，则键会被替换掉。它仍然位于第一个键出现的位置，但是值是最后出现那个键的值。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

48. #### JavaScript全局执行上下文为你做了两件事全局对象和this关键字

JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。
- A: true
- B: false
- C: it depends

<details><summary><b>答案</b></summary>
<p>

 答案: A

基本执行上下文是全局执行上下文：它是代码中随处可访问的内容。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

49. #### 输出什么20

```javascript
for (let i = 1; i < 5; i++) {
  if (i === 3) continue
  console.log(i)
}
```

- A: `1` `2`
- B: `1` `2` `3`
- C: `1` `2` `4`
- D: `1` `3` `4`

<details><summary><b>答案</b></summary>
<p>

 答案: C

如果某个条件返回 `true`，则 `continue` 语句跳过本次迭代。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

50. ####  原型方法

```javascript
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!'
}

const name = 'Lydia'

name.giveLydiaPizza()
```

- A: `"Just give Lydia pizza already!"`
- B: `TypeError: not a function`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>答案</b></summary>
<p>

 答案: A

`String` 是内置的构造函数，我们可以向它添加属性。我只是在它的原型中添加了一个方法。基本类型字符串被自动转换为字符串对象，由字符串原型函数生成。因此，所有 string(string 对象)都可以访问该方法！

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

51. ####  输出什么22

```javascript
const a = {}
const b = { key: 'b' }
const c = { key: 'c' }

a[b] = 123
a[c] = 456

console.log(a[b])
```

- A: `123`
- B: `456`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>答案</b></summary>
<p>

 答案: B

对象的键被自动转换为字符串。我们试图将一个对象 `b` 设置为对象 `a` 的键，且相应的值为 `123`。

然而，当字符串变成一个对象时，它会变成 `"[object Object]"`。因此这里说的是，`a["[object Object]"] = 123`。然后，我们再一次做了同样的事情，`c` 是另外一个对象，这里也有隐式字符串化，于是，`a["[object Object]"] = 456`。

然后，我们打印 `a[b]`，也就是 `a["[object Object]"]`。之前刚设置为 `456`，因此返回的是 `456`。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

52. ####  事件循环

- 题目一
```javascript
const foo = () => console.log('First')
const bar = () => setTimeout(() => console.log('Second'))
const baz = () => console.log('Third')

bar()
foo()
baz()
```

- A: `First` `Second` `Third`
- B: `First` `Third` `Second`
- C: `Second` `First` `Third`
- D: `Second` `Third` `First`

- 题目二
```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
  }

  async function async2() {
    console.log('async2');
  }

  console.log('script start');

  setTimeout(function () {
    console.log('setTimeout');
  }, 0);

  async1();

  new Promise(function (resolve) {
    console.log('promise1');
    resolve();
  }).then(function () {
    console.log('promise2');
  });

  console.log('script end');
```
<details><summary><b>答案</b></summary>

题目一答案: B

我们有一个 `setTimeout` 函数，并首先调用它。然而，它是最后打印日志的。

这是因为在浏览器中，我们不仅有运行时引擎，还有一个叫做 `WebAPI` 的东西。`WebAPI` 提供了 `setTimeout` 函数，也包含其他的，例如 DOM。

将 _callback_ 推送到 WebAPI 后，`setTimeout` 函数本身(但不是回调！)将从栈中弹出。

<img src="https://i.imgur.com/X5wsHOg.png" width="200">

现在，`foo` 被调用，打印 `"First"`。

<img src="https://i.imgur.com/Pvc0dGq.png" width="200">

`foo` 从栈中弹出，`baz` 被调用. 打印 `"Third"`。

<img src="https://i.imgur.com/WhA2bCP.png" width="200">

WebAPI 不能随时向栈内添加内容。相反，它将回调函数推到名为 _queue_ 的地方。

<img src="https://i.imgur.com/NSnDZmU.png" width="200">

这就是事件循环开始工作的地方。一个**事件循环**查看栈和任务队列。如果栈是空的，它接受队列上的第一个元素并将其推入栈。

<img src="https://i.imgur.com/uyiScAI.png" width="200">

`bar` 被调用，打印 `"Second"`，然后它被栈弹出。

题目二答案：
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout

首先，js是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应DOM的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被push进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步HTTP请求线程满足特定条件下的回调函数push到事件队列中，等待js引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务microtask（promise），如果有那就优先执行微任务，如果没有，在去查找宏任务macrotask（setTimeout、setInterval）进行执行。

在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。

当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行

[详解JavaScript中的Event Loop（事件循环）机制](https://zhuanlan.zhihu.com/p/33058983)
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

53. ####  <a id="click_button_event_target"></a> 当点击按钮时，event.target是什么

```html
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">
      Click!
    </button>
  </div>
</div>
```

- A: Outer `div`
- B: Inner `div`
- C: `button`
- D: 一个包含所有嵌套元素的数组。

<details><summary><b>答案</b></summary>
<p>

 答案: C

导致事件的最深嵌套的元素是事件的 `target`。你可以通过 `event.stopPropagation` 来停止冒泡。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

54. ####  当您单击该段落时日志输出是什么

当您单击该段落时，日志输出是什么？
```html
<div onclick="console.log('div')">
  <p onclick="console.log('p')">
    Click here!
  </p>
</div>
```

- A: `p` `div`
- B: `div` `p`
- C: `p`
- D: `div`

<details><summary><b>答案</b></summary>
<p>

 答案: A

如果我们点击 `p`，我们会看到两个日志：`p` 和 `div`。在事件传播期间，有三个阶段：捕获、目标和冒泡。默认情况下，事件处理程序在冒泡阶段执行（除非将 `useCapture` 设置为 `true`）。它从嵌套最深的元素向外传播。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

55. ####  输出什么24

```javascript
const person = { name: 'Lydia' }

function sayHi(age) {
  console.log(`${this.name} is ${age}`)
}

sayHi.call(person, 21)
sayHi.bind(person, 21)
```

- A: `undefined is 21` `Lydia is 21`
- B: `function` `function`
- C: `Lydia is 21` `Lydia is 21`
- D: `Lydia is 21` `function`

<details><summary><b>答案</b></summary>
<p>

 答案: D

使用这两种方法，我们都可以传递我们希望 `this` 关键字引用的对象。但是，`.call` 是**立即执行**的。

`.bind` 返回函数的**副本**，但带有绑定上下文！它不是立即执行的。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

56. ####  输出什么25

```javascript
function sayHi() {
  return (() => 0)()
}

typeof sayHi()
```

- A: `"object"`
- B: `"number"`
- C: `"function"`
- D: `"undefined"`

<details><summary><b>答案</b></summary>
<p>

 答案: B

`sayHi` 方法返回的是立即执行函数(IIFE)的返回值.此立即执行函数的返回值是 `0`， 类型是 `number`

参考：只有7种内置类型：`null`，`undefined`，`boolean`，`number`，`string`，`object` 和 `symbol`。 ``function`` 不是一种类型，函数是对象，它的类型是``object``。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

57.  ####  下面哪些值是falsy

```javascript
0
new Number(0)
;('')
;(' ')
new Boolean(false)
undefined
```

- A: `0`, `''`, `undefined`
- B: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`
- C: `0`, `''`, `new Boolean(false)`, `undefined`
- D: All of them are falsy

<details><summary><b>答案</b></summary>
<p>

 答案: A

只有 6 种 [falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy) 值:

if (false)
if (null)
if (undefined)
if (0)
if (NaN)
if ('')
if ("")
if (document.all)

`Function` 构造函数, 比如 `new Number` 和 `new Boolean`，是 [truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

58. ####  输出什么26

```javascript
console.log(typeof typeof 1)
```

- A: `"number"`
- B: `"string"`
- C: `"object"`
- D: `"undefined"`

<details><summary><b>答案</b></summary>
<p>

 答案: B

`typeof 1` 返回 `"number"`。
`typeof "number"` 返回 `"string"`。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

59. ####  输出什么27

```javascript
const numbers = [1, 2, 3]
numbers[10] = 11
console.log(numbers)
```

- A: `[1, 2, 3, 7 x null, 11]`
- B: `[1, 2, 3, 11]`
- C: `[1, 2, 3, 7 x empty, 11]`
- D: `SyntaxError`

<details><summary><b>答案</b></summary>
<p>

 答案: C

当你为数组设置超过数组长度的值的时候， JavaScript 会创建名为 "empty slots" 的东西。它们的值实际上是 `undefined`。你会看到以下场景：

`[1, 2, 3, 7 x empty, 11]`

这取决于你的运行环境（每个浏览器，以及 node 环境，都有可能不同）

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

60. ####  输出什么28

```javascript
;(() => {
  let x, y
  try {
    throw new Error()
  } catch (x) {
    ;(x = 1), (y = 2)
    console.log(x)
  }
  console.log(x)
  console.log(y)
})()
```

- A: `1` `undefined` `2`
- B: `undefined` `undefined` `undefined`
- C: `1` `1` `2`
- D: `1` `undefined` `undefined`

<details><summary><b>答案</b></summary>
<p>

 答案: A

`catch` 代码块接收参数 `x`。当我们传递参数时，这与之前定义的变量 `x` 不同 。这个 `x` 是属于 `catch` 块级作用域的。

然后，我们将块级作用域中的变量赋值为 `1`，同时也设置了变量 `y` 的值。现在，我们打印块级作用域中的变量 `x`，值为 `1`。

`catch` 块之外的变量 `x` 的值仍为 `undefined`， `y` 的值为 `2`。当我们在 `catch` 块之外执行 `console.log(x)` 时，返回 `undefined`，`y` 返回 `2`。

</p>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

61. ####  自己开发的框架或者库如何使用原型

对于 JavaScript 原型的考察，应该算是基础知识的一部分。但是，基础知识考察的只是原型的理论，而高级知识考察的是原型的实际使用。我们使用的绝大部分第三方框架或者库，源码中都有原型的使用。如果你不能熟练使用原型，你能自己写框架或者库

所以，这里要考察的是原型如何在实际的框架和库中去使用。对于这个问题，如果你没有亲自写过框架和库，且对原型不是很熟悉，那么我建议你看一下 jQuery zepto 中是如何使用原型的。这也算是站在巨人的肩膀上吧，毕竟都是如此优秀的库。

jQuery 的资料自己上网去找找吧，给大家推荐一个免费的讲解 zepto 原型的视频资料 [《zepto设计和源码分析》](https://www.imooc.com/learn/745)。

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

62.  ####  目前JS对于异步的解决方案有哪些

<details><summary><b>答案</b></summary>
异步是 JS 永恒的话题，自动 web 2.0 有了 Ajax 开始，到现在 nodejs 盛行，人们就一直没有停止对异步的讨论。大家有没有考虑过为何异步这么受欢迎？—— 因为异步和业务场景的结合实在太紧密了。在复杂的业务场景中，你要能一眼就识别出来哪些是异步，而且要找到最佳的解决方案，否则这里就是一个坑。

这里没有问“JS 中有哪些场景是异步”，因为这个问题如果只回答“图片加载、ajax”等没有什么意义，异步是要结合实际业务说的。因此这里提问异步的解决方案，我列一下，你来看看自己是否都全部了解。

- deferred （jQuery 或者 zepto 中）—— 注意，这块很多同学不知道，可以多去查查相关资料，因为 jQuery 和 zepto 目前还有很多、很多、很多项目在用！！！
- Promise（ES6 或者第三方库，如 q.js bluebird.js），不仅要知道怎么用，还要熟悉 Promise 的标准
- Generator（从 koa 升级 2.x 之后已经不再常用）
- async/await （ES7 草案）

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

63.  ####   常用的ES6的语法有哪些

<details><summary><b>答案</b></summary>
虽然目前浏览器对 ES6 兼容性不好，但是 ES6 已经在开发环境很普及了，因此要考察 ES6 的语法。
看 ES6 的书籍或者博客，内容还是挺多的，但是日常实际使用的功能并没有那么多。这里我列举几个常用的，你对照着去考察自己是否掌握全面

##### 箭头函数（Arrow Functions）
ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =>，紧接着是函数体：
当然，箭头函数不仅仅是让代码变得简洁，函数中 this 总是绑定总是指向对象自身。
##### let、const 和 block 作用域
let 关键词声明的变量不具备变量提升（hoisting）特性
let 和 const 声明只在最靠近的一个块中（花括号内）有效
当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING
const 在声明时必须被赋值
##### 函数参数默认值
```js
1 let getFinalPrice = (price, tax=0.7) => price + price * tax;
2 getFinalPrice(500); // 850
```
##### Spread(展开) / Rest(剩余) 操作符...
Spread / Rest 操作符指的是 ...，具体是 Spread 还是 Rest 需要看上下文语境。

当被用于迭代器中时，它是一个 Spread 操作符：
```js
function foo(x,y,z) {
  console.log(x,y,z);
}

let arr = [1,2,3];
foo(...arr); // 1 2 3
```
当被用于函数传参时，是一个 Rest 操作符：
```js
function foo(...args) {
   console.log(args);
 }
foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
```
##### 对象词法扩展
ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作：
```js
function getCar(make, model, value) {
  return {
    // 简写变量
    make,  // 等同于 make: make
    model, // 等同于 model: model
    value, // 等同于 value: value

    // 属性可以使用表达式计算值
    ['make' + make]: true,

    // 忽略 `function` 关键词简写对象函数
    depreciate() {
      this.value -= 2500;
    }
  };
}

let car = getCar('Barret', 'Lee', 40000);

// output: {
//     make: 'Barret',
//     model:'Lee',
//     value: 40000,
//     makeBarret: true,
//     depreciate: function()
// }
```
##### 对象和数组解构
解构可以避免在对象赋值时产生中间变量
##### 对象超类
```js
var parent = {
  foo() {
    console.log("Hello from the Parent");
  }
}

var child = {
  foo() {
    super.foo();
    console.log("Hello from the Child");
  }
}

Object.setPrototypeOf(child, parent);//将child的原型指向parent
child.foo(); // Hello from the Parent
             // Hello from the Child
```
##### 模板语法和分隔符
ES6 中有一种十分简洁的方法组装一堆字符串和变量。

${ ... } 用来渲染一个变量
` 作为分隔符
#####  for...of VS for...in
```js
for...of 用于遍历一个迭代器，如数组：

let nicknames = ['di', 'boo', 'punkeye'];
nicknames.size = 3;
for (let nickname of nicknames) {
  console.log(nickname);
}
Result: di, boo, punkeye
for...in 用来遍历对象中的属性：

let nicknames = ['di', 'boo', 'punkeye'];
nicknames.size = 3;
for (let nickname in nicknames) {
  console.log(nickname);
}
Result: 0, 1, 2, size
```
##### Map 和 WeakMap
ES6 中两种新的数据结构集：Map 和 WeakMap。事实上每个对象都可以看作是一个 Map。

一个对象由多个 key-val 对构成，在 Map 中，任何类型都可以作为对象的 key

WeakMap 就是一个 Map，只不过它的所有 key 都是弱引用，意思就是 WeakMap 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题。
 
另一个需要注意的点是，WeakMap 的所有 key 必须是对象。它只有四个方法 delete(key),has(key),get(key) 和 set(key, val)
#####  Set 和 WeakSet
Set 对象是一组不重复的值，重复的值将被忽略，值类型可以是原始类型和引用类型
Set 同样有 delete() 和 clear() 方法。

WeakSet

类似于 WeakMap，WeakSet 对象可以让你在一个集合中保存对象的弱引用，在 WeakSet 中的对象只允许出现一次
##### 类
ES6 中有 class 语法。值得注意是，这里的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。

函数中使用 static 关键词定义构造函数的的方法和属性：
```js
class Task {
  constructor() {
    console.log("task instantiated!");
  }

  showId() {
    console.log(23);
  }

  static loadAll() {
    console.log("Loading all tasks..");
  }
}

console.log(typeof Task); // function
let task = new Task(); // "task instantiated!"
task.showId(); // 23
Task.loadAll(); // "Loading all tasks.."
```

类中的继承和超集：
```js
class Car {
  constructor() {
    console.log("Creating a new car");
  }
}

class Porsche extends Car {
  constructor() {
    super();
    console.log("Creating Porsche");
  }
}

let c = new Porsche();
// Creating a new car
// Creating Porsche
```

extends 允许一个子类继承父类，需要注意的是，子类的 constructor 函数中需要执行 super() 函数。

当然，你也可以在子类方法中调用父类的方法，如 super.parentMethodName()。

在 这里 阅读更多关于类的介绍。

有几点值得注意的是：

类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误
在类中定义函数不需要使用 function 关键词

##### Symbol
Symbol 是一种新的数据类型，它的值是唯一的，不可变的。ES6 中提出 symbol 的目的是为了生成一个唯一的标识符，不过你访问不到这个标识符
```js
1 var sym = Symbol( "some optional description" );
2 console.log(typeof sym); // symbol
```
注意，这里 Symbol 前面不能使用 new 操作符。

如果它被用作一个对象的属性，那么这个属性会是不可枚举的：
```js
var o = {
    val: 10,
    [ Symbol("random") ]: "I'm a symbol",
};

console.log(Object.getOwnPropertyNames(o)); // val
```
如果要获取对象 symbol 属性，需要使用 Object.getOwnPropertySymbols(o)。
##### 迭代器（Iterators）
迭代器允许每次访问数据集合的一个元素，当指针指向数据集合最后一个元素是，迭代器便会退出。它提供了 next() 函数来遍历一个序列，这个方法返回一个包含 done 和 value 属性的对象。

ES6 中可以通过 Symbol.iterator 给对象设置默认的遍历器，无论什么时候对象需要被遍历，执行它的 @@iterator 方法便可以返回一个用于获取值的迭代器。

数组默认就是一个迭代器：
```js
var arr = [11,12,13];
var itr = arr[Symbol.iterator]();

itr.next(); // { value: 11, done: false }
itr.next(); // { value: 12, done: false }
itr.next(); // { value: 13, done: false }

itr.next(); // { value: undefined, done: true }
```
你可以通过 [Symbol.iterator]() 自定义一个对象的迭代器。

##### Generators
Generator 函数是 ES6 的新特性，它允许一个函数返回的可遍历对象生成多个值。

在使用中你会看到 * 语法和一个新的关键词 yield

##### Promise
ES6 对 Promise 有了原生的支持，一个 Promise 是一个等待被异步执行的对象，当它执行完成后，其状态会变成 resolved 或者 rejected。
##### proxy
代理
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

64. ####  vue如何解析模板

<details><summary><b>答案</b></summary>
简单来说，模板解析分位三步

- 模板就是一段字符串，非结构化的数据，没法分析。因此，第一步是将非结构化的模板字符串，转变成结构化的 JS 对象，抽象语法树，即 AST 。其实就是一个 JS 对象，这样就结构化了。
- 第二步，将 AST 转换成一个 render 函数，步骤是先转换为一段函数体的字符串，然后再用new Function(...)生成函数。
- 第三部，渲染时执行 render 函数，返回虚拟 DOM 对象，然后执行虚拟 DOM 的patch方法，渲染成真正的 html 。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

65. ####  React的setState为何是异步渲染

<details><summary><b>答案</b></summary>
这个问题其实很简单，只是很多同学没有考虑到。答案就是：为了防止一次性执行多次setState而带来的渲染性能问题。即，你如果连续不断执行 100 次setState的话，那么 React 是否有必要渲染 100 次？—— 肯定没必要。第一，浏览器会卡死；第二，用户只需要看到最后的结果即可，不用关心前 99 次的过程。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

66. ####  hybrid和h5有何区别

<details><summary><b>答案</b></summary>
本题目是面试官考察 hybrid 经常问的一道题，最主要的区别在于：

- hybrid 是通过file协议加载的本地文件，h5 是通过http协议加载的网络文件，前者速度快。
- hybrid 是通过为不同版本打包进行更新，而 h5 没有版本的概念，每次都获取服务端的最新版。
- hybrid 更加依赖于客户端的能力，因此会更多的和客户端通讯，而 h5 基本用不到和客户端通讯。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

67. ####  JavaScript中的一切都是

A: 基本类型与对象
B: 函数与对象
C: 只有对象
D: 数字与对象
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>

JavaScript 只有基本类型和对象。

基本类型包括 boolean, null, undefined, bigint, number, string, symbol。

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

68. ####  输出什么29

``` js
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur)
  },
  [1, 2]
)
```
A: [0, 1, 2, 3, 1, 2]
B: [6, 1, 2]
C: [1, 2, 0, 1, 2, 3]
D: [1, 2, 6]
<details><summary><b>答案</b></summary>
<p>

 答案: C
</p>

[1, 2]是初始值。初始值将会作为首次调用时第一个参数 acc 的值。在第一次执行时， acc 的值是 [1, 2]， cur 的值是 [0, 1]。合并它们，结果为 [1, 2, 0, 1]。 第二次执行， acc 的值是 [1, 2, 0, 1]， cur 的值是 [2, 3]。合并它们，最终结果为 [1, 2, 0, 1, 2, 3]

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

69. ####  输出什么30

```
!!null
!!''
!!1
```
A: false true false
B: false false true
C: false true true
D: true true false

<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>

null 是 falsy。 !null 的值是 true。 !true 的值是 false。

"" 是 falsy。 !"" 的值是 true。 !true 的值是 false。

1 是 truthy。 !1 的值是 false。 !false 的值是 true。

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

70. ####  setInterval方法的返回值是什么

```js
setInterval(() => console.log('Hi'), 1000)
```
A: 一个唯一的id
B: 该方法指定的毫秒数
C: 传递的函数
D: undefined


<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>

setInterval 返回一个唯一的 id。此 id 可被用于 clearInterval 函数来取消定时。

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

71. ####  输出什么31

```js
[...'Lydia']
```
A: ["L", "y", "d", "i", "a"]
B: ["Lydia"]
C: [[], "Lydia"]
D: [["L", "y", "d", "i", "a"]]


<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>

string 类型是可迭代的。扩展运算符将迭代的每个字符映射成一个元素。

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

72. ####  输出什么32

```js
function* generator(i) {
  yield i;
  yield i * 2;
}

const gen = generator(10);

console.log(gen.next().value);
console.log(gen.next().value);
```
A: [0, 10], [10, 20]
B: 20, 20
C: 10, 20
D: 0, 10 and 10, 20


<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>

一般的函数在执行之后是不能中途停下的。但是，生成器函数却可以中途“停下”，之后可以再从停下的地方继续。当生成器遇到yield关键字的时候，会生成yield后面的值。注意，生成器在这种情况下不 返回 (return )值，而是 生成 (yield)值。

首先，我们用10作为参数i来初始化生成器函数。然后使用next()方法一步步执行生成器。第一次执行生成器的时候，i的值为10，遇到第一个yield关键字，它要生成i的值。此时，生成器“暂停”，生成了10。

然后，我们再执行next()方法。生成器会从刚才暂停的地方继续，这个时候i还是10。于是我们走到了第二个yield关键字处，这时候需要生成的值是i*2，i为10，那么此时生成的值便是20。所以这道题的最终结果是10,20。

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

73. ####  返回值是什么

```js
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, "one");
});

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, "two");
});

Promise.race([firstPromise, secondPromise]).then(res => console.log(res));
```
A: "one"
B: "two"
C: "two" "one"
D: "one" "two"

<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>

当我们向Promise.race方法中传入多个Promise时，会进行 优先 解析。在这个例子中，我们用setTimeout给firstPromise和secondPromise分别设定了500ms和100ms的定时器。这意味着secondPromise会首先解析出字符串two。那么此时res参数即为two，是为输出结果。

哪个快就输出哪个
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

74. ####  输出什么33

```js
let person = { name: "Lydia" };
const members = [person];
person = null;

console.log(members);
```
A: null
B: [null]
C: [{}]
D: [{ name: "Lydia" }]

<details><summary><b>答案</b></summary>
<p>

 答案: D

</p>
首先我们声明了一个拥有name属性的对象 person。

![avatar](./public/74-1.png)

然后我们又声明了一个变量members. 将首个元素赋值为变量person。 当设置两个对象彼此相等时，它们会通过 引用 进行交互。但是当你将引用从一个变量分配至另一个变量时，其实只是执行了一个 复制 操作。（注意一点，他们的引用 并不相同!）

![avatar](./public/74-2.png)

接下来我们让person等于null。

![avatar](./public/74-3.png)

我们没有修改数组第一个元素的值，而只是修改了变量person的值,因为元素（复制而来）的引用与person不同。members的第一个元素仍然保持着对原始对象的引用。当我们输出members数组时，第一个元素会将引用的对象打印出来。

和对象的引用是不同的
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

75. #### 输出什么34

```js
const person = {
  name: "Lydia",
  age: 21
};

for (const item in person) {
  console.log(item);
}
```
A: { name: "Lydia" }, { age: 21 }
B: "name", "age"
C: "Lydia", 21
D: ["name", "Lydia"], ["age", 21]


<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>

在for-in循环中,我们可以通过对象的key来进行迭代,也就是这里的name和age。在底层，对象的key都是字符串（如果他们不是Symbol的话）。在每次循环中，我们将item设定为当前遍历到的key.所以一开始，item是name，之后 item输出的则是age。

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

76. ####  输出什么35

```js
console.log(3 + 4 + "5");
```
A: "345"
B: "75"
C: 12
D: "12"


<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>
当所有运算符的 优先级 相同时，计算表达式需要确定运算符的结合顺序，即从右到左还是从左往右。在这个例子中，我们只有一类运算符+，对于加法来说，结合顺序就死从左到右。

3 + 4首先计算，得到数字7.

由于类型的强制转换，7 + '5'的结果是"75". JavaScript将7转换成了字符串，可以参考问题15.我们可以用+号把两个字符串连接起来。 "7" + "5" 就得到了"75".
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

77. #### 输出什么36

```js
const num = parseInt("7*6", 10);
```
A: 42
B: "42"
C: 7
D: NaN

<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>
只返回了字符串中第一个字母. 设定了 进制 后 (也就是第二个参数，指定需要解析的数字是什么进制: 十进制、十六机制、八进制、二进制等等……),parseInt 检查字符串中的字符是否合法. 一旦遇到一个在指定进制中不合法的字符后，立即停止解析并且忽略后面所有的字符。

*就是不合法的数字字符。所以只解析到"7"，并将其解析为十进制的7. num的值即为7.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

78. #### 输出什么37

```js
[1, 2, 3].map(num => {
  if (typeof num === "number") return;
  return num * 2;
});
```
A: []
B: [null, null, null]
C: [undefined, undefined, undefined]
D: [ 3 x empty ]

<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>
对数组进行映射的时候,num就是当前循环到的元素. 在这个例子中，所有的映射都是number类型，所以if中的判断typeof num === "number"结果都是true.map函数创建了新数组并且将函数的返回值插入数组。

但是，没有任何值返回。当函数没有返回任何值时，即默认返回undefined.对数组中的每一个元素来说，函数块都得到了这个返回值，所以结果中每一个元素都是undefined.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

79. #### 输出什么38

```js

function getInfo(member, year) {
  member.name = "Lydia";
  year = "1998";
}

const person = { name: "Sarah" };
const birthYear = "1997";

getInfo(person, birthYear);

console.log(person, birthYear);

A: { name: "Lydia" }, "1997"
B: { name: "Sarah" }, "1998"
C: { name: "Lydia" }, "1998"
D: { name: "Sarah" }, "1997"
```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>

普通参数都是 值 传递的，而对象则不同，是 引用 传递。所以说，birthYear是值传递，因为他是个字符串而不是对象。当我们对参数进行值传递时，会创建一份该值的 复制 。（可以参考问题46）

变量birthYear有一个对"1997"的引用，而传入的参数也有一个对"1997"的引用，但二者的引用并不相同。当我们通过给 year赋值"1998"来更新year的值的时候我们只是更新了year（的引用）。此时birthYear仍然是"1997".

而person是个对象。参数member引用与之 相同的 对象。当我们修改member所引用对象的属性时,person的相应属性也被修改了,因为他们引用了相同的对象. person的 name属性也变成了 "Lydia".
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

80. #### 输出什么39

```js
function greeting() {
  throw "Hello world!";
}

function sayHi() {
  try {
    const data = greeting();
    console.log("It worked!", data);
  } catch (e) {
    console.log("Oh no an error!", e);
  }
}

sayHi();
A: "It worked! Hello world!"
B: "Oh no an error: undefined
C: SyntaxError: can only throw Error objects
D: "Oh no an error: Hello world!
```
<details><summary><b>答案</b></summary>
<p>

 答案: D

</p>
通过throw语句，我么可以创建自定义错误。 而通过它，我们可以抛出异常。异常可以是一个字符串, 一个 数字, 一个 布尔类型 或者是一个 对象。在本例中，我们的异常是字符串'Hello world'.

通过 catch语句，我们可以设定当try语句块中抛出异常后应该做什么处理。在本例中抛出的异常是字符串'Hello world'. e就是这个字符串，因此被输出。最终结果就是'Oh an error: Hello world'.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

81. #### 输出什么40

```js
function Car() {
  this.make = "Lamborghini";
  return { make: "Maserati" };
}

const myCar = new Car();
console.log(myCar.make);
A: "Lamborghini"
B: "Maserati"
C: ReferenceError
D: TypeError
```

<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>
返回属性的时候，属性的值等于 返回的 值，而不是构造函数中设定的值。我们返回了字符串 "Maserati"，所以 myCar.make等于"Maserati".

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

82. #### 输出什么41

```js
(() => {
  let x = (y = 10);
})();

console.log(typeof x);
console.log(typeof y);
A: "undefined", "number"
B: "number", "number"
C: "object", "number"
D: "number", "undefined"
```
<details><summary><b>答案</b></summary>
<p>

答案: A

</p>
let x = y = 10; 是下面这个表达式的缩写:

y = 10;
let x = y;
我们设定y等于10时,我们实际上增加了一个属性y给全局对象(浏览器里的window, Nodejs里的global)。在浏览器中， window.y等于10.

然后我们声明了变量x等于y,也是10.但变量是使用 let声明的，它只作用于 块级作用域, 仅在声明它的块中有效；就是案例中的立即调用表达式(IIFE)。使用typeof操作符时, 操作值 x没有被定义：因为我们在x声明块的外部，无法调用它。这就意味着x未定义。未分配或是未声明的变量类型为"undefined". console.log(typeof x)返回"undefined".

而我们创建了全局变量y，并且设定y等于10.这个值在我们的代码各处都访问的到。 y已经被定义了，而且有一个"number"类型的值。 console.log(typeof y)返回"number".
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

83. #### 输出什么42

```js
class Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.bark = function() {
  console.log(`Woof I am ${this.name}`);
};

const pet = new Dog("Mara");

pet.bark();

delete Dog.prototype.bark;

pet.bark();
A: "Woof I am Mara", TypeError
B: "Woof I am Mara","Woof I am Mara"
C: "Woof I am Mara", undefined
D: TypeError, TypeError
```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
我们可以用delete关键字删除对象的属性，对原型也是适用的。删除了原型的属性后，该属性在原型链上就不可用了。在本例中，函数bark在执行了delete Dog.prototype.bark后不可用, 然而后面的代码还在调用它。

当我们尝试调用一个不存在的函数时TypeError异常会被抛出。在本例中就是 TypeError: pet.bark is not a function，因为pet.bark是undefined.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

84. #### 输出什么43

```js
const set = new Set([1, 1, 2, 3, 4]);

console.log(set);
A: [1, 1, 2, 3, 4]
B: [1, 2, 3, 4]
C: {1, 1, 2, 3, 4}
D: {1, 2, 3, 4}
```
<details><summary><b>答案</b></summary>
<p>

 答案: D

</p>
Set可以去重
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

85. #### 输出什么44

```js
// counter.js
let counter = 10;
export default counter;
// index.js
import myCounter from "./counter";

myCounter += 1;

console.log(myCounter);
A: 10
B: 11
C: Error
D: NaN
```
<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>
引入的模块是 只读 的: 你不能修改引入的模块。只有导出他们的模块才能修改其值。

当我们给myCounter增加一个值的时候会抛出一个异常： myCounter是只读的，不能被修改。

因为es6中的import和export导入和导出的值都是引用对象，所以import进来的值是无法修改的

但是commonjs中的require和exports不一样，require进来的值会开辟一个新的内存空间，所以可以修改。

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

86. #### 输出什么45

```js
const name = "Lydia";
age = 21;

console.log(delete name);
console.log(delete age);
A: false, true
B: "Lydia", 21
C: true, true
D: undefined, undefined
```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
delete操作符返回一个布尔值： true指删除成功，否则返回false. 但是通过 var, const 或 let 关键字声明的变量无法用 delete 操作符来删除。

name变量由const关键字声明，所以删除不成功:返回 false. 而我们设定age等于21时,我们实际上添加了一个名为age的属性给全局对象。对象中的属性是可以删除的，全局对象也是如此，所以delete age返回true.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

87. #### 输出什么46

```js
const numbers = [1, 2, 3, 4, 5];
const [y] = numbers;

console.log(y);
A: [[1, 2, 3, 4, 5]]
B: [1, 2, 3, 4, 5]
C: 1
D: [1]
```
<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>
我们可以通过解构赋值来解析来自对象的数组或属性的值，比如说：

[a, b] = [1, 2];

a的值现在是1，b的值现在是2.而在题目中，我们是这么做的:

[y] = [1, 2, 3, 4, 5];

也就是说，y等于数组的第一个值就是数字1.我们输出y， 返回1.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

88. #### 输出什么47

```js
const user = { name: "Lydia", age: 21 };
const admin = { admin: true, ...user };

console.log(admin);
A: { admin: true, user: { name: "Lydia", age: 21 } }
B: { admin: true, name: "Lydia", age: 21 }
C: { admin: true, user: ["Lydia", 21] }
D: { admin: true }
```
<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>
扩展运算符...为对象的组合提供了可能。你可以复制对象中的键值对，然后把它们加到另一个对象里去。在本例中，我们复制了user对象键值对，然后把它们加入到admin对象中。admin对象就拥有了这些键值对，所以结果为{ admin: true, name: "Lydia", age: 21 }.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

89. #### 输出什么48

```js
const person = { name: "Lydia" };

Object.defineProperty(person, "age", { value: 21 });

console.log(person);
console.log(Object.keys(person));
A: { name: "Lydia", age: 21 }, ["name", "age"]
B: { name: "Lydia", age: 21 }, ["name"]
C: { name: "Lydia"}, ["name", "age"]
D: { name: "Lydia"}, ["age"]
```
<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>
通过defineProperty方法，我们可以给对象添加一个新属性，或者修改已经存在的属性。而我们使用defineProperty方法给对象添加了一个属性之后，属性默认为 不可枚举(not enumerable). Object.keys方法仅返回对象中 可枚举(enumerable) 的属性，因此只剩下了"name".

用defineProperty方法添加的属性默认不可变。你可以通过writable, configurable 和 enumerable属性来改变这一行为。这样的话， 相比于自己添加的属性，defineProperty方法添加的属性有了更多的控制权。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

90. #### 输出什么49

```js
const settings = {
  username: "lydiahallie",
  level: 19,
  health: 90
};

const data = JSON.stringify(settings, ["level", "health"]);
console.log(data);
A: "{"level":19, "health":90}"
B: "{"username": "lydiahallie"}"
C: "["level", "health"]"
D: "{"username": "lydiahallie", "level":19, "health":90}"
```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
JSON.stringify的第二个参数是 替代者(replacer). 替代者(replacer)可以是个函数或数组，用以控制哪些值如何被转换为字符串。

如果替代者(replacer)是个 数组 ，那么就只有包含在数组中的属性将会被转化为字符串。在本例中，只有名为"level" 和 "health" 的属性被包括进来， "username"则被排除在外。 data 就等于 "{"level":19, "health":90}".

而如果替代者(replacer)是个 函数，这个函数将被对象的每个属性都调用一遍。 函数返回的值会成为这个属性的值，最终体现在转化后的JSON字符串中（译者注：Chrome下，经过实验，如果所有属性均返回同一个值的时候有异常，会直接将返回值作为结果输出而不会输出JSON字符串），而如果返回值为undefined，则该属性会被排除在外。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

91. #### 输出什么50

```js
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
A: 10, 10
B: 10, 11
C: 11, 11
D: 11, 12
```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
一元操作符 ++ 先返回 操作值, 再累加 操作值。num1的值是10, 因为increaseNumber函数首先返回num的值，也就是10，随后再进行 num的累加。

num2是10因为我们将 num1传入increasePassedNumber. number等于10（num1的值。同样道理，++ 先返回 操作值, 再累加 操作值。） number是10，所以num2也是10.
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

92. #### 输出什么51

```js
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log(x.number *= 2);
};

multiply();
multiply();
multiply(value);
multiply(value);
A: 20, 40, 80, 160
B: 20, 40, 20, 40
C: 20, 20, 20, 40
D: NaN, NaN, 20, 40
```
<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>
在ES6中，我们可以使用默认值初始化参数。如果没有给函数传参，或者传的参值为 "undefined" ，那么参数的值将是默认值。上述例子中，我们将 value 对象进行了解构并传到一个新对象中，因此 x 的默认值为 {number：10} 。

默认参数在调用时才会进行计算，每次调用函数时，都会创建一个新的对象。我们前两次调用 multiply 函数且不传递值，那么每一次 x 的默认值都为 {number：10} ，因此打印出该数字的乘积值为20。

第三次调用 multiply 时，我们传递了一个参数，即对象value。 *=运算符实际上是x.number = x.number * 2的简写，我们修改了x.number的值，并打印出值20。

第四次，我们再次传递value对象。 x.number之前被修改为20，所以x.number * = 2打印为40。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

93. #### 输出什么52

```js
[1, 2, 3, 4].reduce((x, y) => console.log(x, y));
A: 1 2 and 3 3 and 6 4
B: 1 2 and 2 3 and 3 4
C: 1 undefined and 2 undefined and 3 undefined and 4 undefined
D: 1 2 and undefined 3 and undefined 4
```
<details><summary><b>答案</b></summary>
<p>

 答案: D

</p>
reducer 函数接收4个参数:

Accumulator (acc) (累计器)
Current Value (cur) (当前值)
Current Index (idx) (当前索引)
Source Array (src) (源数组)
reducer 函数的返回值将会分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。

reducer 函数还有一个可选参数initialValue, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供initialValue，则将使用数组中的第一个元素。

在上述例子，reduce方法接收的第一个参数(Accumulator)是x, 第二个参数(Current Value)是y。

在第一次调用时，累加器x为1，当前值“y”为2，打印出累加器和当前值：1和2。

例子中我们的回调函数没有返回任何值，只是打印累加器的值和当前值。如果函数没有返回值，则默认返回undefined。 在下一次调用时，累加器为undefined，当前值为“3”, 因此undefined和3被打印出。

在第四次调用时，回调函数依然没有返回值。 累加器再次为 undefined ，当前值为“4”。 undefined和4被打印出。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

94. #### 使用哪个构造函数可以成功继承Dog类

```js
class Dog {
  constructor(name) {
    this.name = name;
  }
};

class Labrador extends Dog {
  // 1 
  constructor(name, size) {
    this.size = size;
  }
  // 2
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  // 3
  constructor(size) {
    super(name);
    this.size = size;
  }
  // 4 
  constructor(name, size) {
    this.name = name;
    this.size = size;
  }

};
A: 1
B: 2
C: 3
D: 4

```
<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>
在子类中，在调用super之前不能访问到this关键字。 如果这样做，它将抛出一个ReferenceError：1和4将引发一个引用错误。

使用super关键字，需要用给定的参数来调用父类的构造函数。 父类的构造函数接收name参数，因此我们需要将name传递给super。

Labrador类接收两个参数，name参数是由于它继承了Dog，size作为Labrador类的额外属性，它们都需要传递给Labrador的构造函数，因此使用构造函数2正确完成。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

95. #### 输出什么53

```js
// index.js
console.log('running index.js');
import { sum } from './sum.js';
console.log(sum(1, 2));

// sum.js
console.log('running sum.js');
export const sum = (a, b) => a + b;
A: running index.js, running sum.js, 3
B: running sum.js, running index.js, 3
C: running sum.js, 3, running index.js
D: running index.js, undefined, running sum.js
```
<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>
import命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。

这是CommonJS中require（）和import之间的区别。使用require()，您可以在运行代码时根据需要加载依赖项。 如果我们使用require而不是import，running index.js，running sum.js，3会被依次打印。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

96. #### 输出什么54

```js
console.log(Number(2) === Number(2))
console.log(Boolean(false) === Boolean(false))
console.log(Symbol('foo') === Symbol('foo'))
A: true, true, false
B: false, true, false
C: true, false, true
D: true, true, true
```
<details><summary><b>答案</b></summary>
<p>

答案: A

</p>
每个Symbol都是完全唯一的。传递给Symbol的参数只是给Symbol的一个描述。 Symbol的值不依赖于传递的参数。 当我们测试相等时，我们创建了两个全新的符号：第一个Symbol（'foo'），第二个Symbol（'foo'）, 这两个值是唯一的，彼此不相等，因此返回false。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

97. #### 输出什么55

```js
const name = "Lydia Hallie"
console.log(name.padStart(13))
console.log(name.padStart(2))
A: "Lydia Hallie", "Lydia Hallie"
B: " Lydia Hallie", " Lydia Hallie" ("[13x whitespace]Lydia Hallie", "[2x whitespace]Lydia Hallie")
C: " Lydia Hallie", "Lydia Hallie" ("[1x whitespace]Lydia Hallie", "Lydia Hallie")
D: "Lydia Hallie", "Lyd"

```
<details><summary><b>答案</b></summary>
<p>

答案: C

</p>
使用padStart方法，我们可以在字符串的开头添加填充。传递给此方法的参数是字符串的总长度（包含填充）。字符串Lydia Hallie的长度为12, 因此name.padStart（13）在字符串的开头只会插入1（13 - 12 = 1）个空格。

如果传递给padStart方法的参数小于字符串的长度，则不会添加填充。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

98. #### 输出什么56

```js
console.log("🥑" + "💻");
A: "🥑💻"
B: 257548
C: A string containing their code points
D: Error

```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
使用+运算符，您可以连接字符串。 上述情况，我们将字符串“🥑”与字符串”💻“连接起来，产生”🥑💻“。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

99. #### 如何能打印出consolelog语句后注释掉的值

如何能打印出console.log语句后注释掉的值
```js
function* startGame() {
  const answer = yield "Do you love JavaScript?";
  if (answer !== "Yes") {
    return "Oh wow... Guess we're gone here";
  }
  return "JavaScript loves you back ❤️";
}

const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back ❤️
A: game.next("Yes").value and game.next().value
B: game.next.value("Yes") and game.next.value()
C: game.next().value and game.next("Yes").value
D: game.next.value() and game.next.value("Yes")

```
<details><summary><b>答案</b></summary>
<p>

答案: C

</p>
generator函数在遇到yield关键字时会“暂停”其执行。 首先，我们需要让函数产生字符串Do you love JavaScript?，这可以通过调用game.next().value来完成。上述函数的第一行就有一个yield关键字，那么运行立即停止了，yield表达式本身没有返回值，或者说总是返回undefined, 这意味着此时变量 answer 为undefined

next方法可以带一个参数，该参数会被当作上一个 yield 表达式的返回值。当我们调用game.next("Yes").value时，先前的 yield 的返回值将被替换为传递给next()函数的参数"Yes"。此时变量 answer 被赋值为 "Yes"，if语句返回false，所以JavaScript loves you back ❤️被打印。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

100. #### 输出什么57

```js
console.log(String.raw`Hello\nworld`);
A: Hello world!
B: Hello 
     world
C: Hello\nworld
D: Hello\n 
     world

```
<details><summary><b>答案</b></summary>
<p>

答案: C

</p>

String.raw函数是用来获取一个模板字符串的原始字符串的，它返回一个字符串，其中忽略了转义符（\n，\v，\t等）。但反斜杠可能造成问题，因为你可能会遇到下面这种类似情况：
```js
const path = `C:\Documents\Projects\table.html`
String.raw`${path}`

```
这将导致：
```js

"C:DocumentsProjects able.html"
```
直接使用String.raw
```js
String.raw`C:\Documents\Projects\table.html`
```
它会忽略转义字符并打印：C:\Documents\Projects\table.html

上述情况，字符串是Hello\nworld被打印出。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

101. #### 输出什么58

```js
async function getData() {
  return await Promise.resolve("I made it!");
}

const data = getData();
console.log(data);
A: "I made it!"
B: Promise {<resolved>: "I made it!"}
C: Promise {<pending>}
D: undefined

```
<details><summary><b>答案</b></summary>
<p>

答案: C

</p>
异步函数始终返回一个promise。await仍然需要等待promise的解决：当我们调用getData()并将其赋值给data，此时data为getData方法返回的一个挂起的promise，该promise并没有解决。

如果我们想要访问已解决的值"I made it!"，可以在data上使用.then()方法：

data.then(res => console.log(res))

这样将打印 "I made it!"
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

102. #### 输出什么59

```js
function addToList(item, list) {
  return list.push(item);
}

const result = addToList("apple", ["banana"]);
console.log(result);
A: ['apple', 'banana']
B: 2
C: true
D: undefined

```
<details><summary><b>答案</b></summary>
<p>

答案: B

</p>
push()方法返回新数组的长度。一开始，数组包含一个元素（字符串"banana"），长度为1。 在数组中添加字符串"apple"后，长度变为2，并将从addToList函数返回。

push方法修改原始数组，如果你想从函数返回数组而不是数组长度，那么应该在push item之后返回list。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

103. #### 输出什么60

```js
const box = { x: 10, y: 20 };

Object.freeze(box);

const shape = box;
shape.x = 100;
console.log(shape)
A: { x: 100, y: 20 }
B: { x: 10, y: 20 }
C: { x: 100 }
D: ReferenceError
```
<details><summary><b>答案</b></summary>
<p>

答案: B

</p>
Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。

Object.freeze使得无法添加、删除或修改对象的属性（除非属性的值是另一个对象）。

当我们创建变量shape并将其设置为等于冻结对象box时，shape指向的也是冻结对象。你可以使用Object.isFrozen检查一个对象是否被冻结，上述情况，Object.isFrozen（shape）将返回true。

由于shape被冻结，并且x的值不是对象，所以我们不能修改属性x。 x仍然等于10，{x：10，y：20}被打印。

注意，上述例子我们对属性x进行修改，可能会导致抛出TypeError异常（最常见但不仅限于严格模式下时）。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

104. #### 输出什么61

```js
const { name: myName } = { name: "Lydia" };

console.log(name);
A: "Lydia"
B: "myName"
C: undefined
D: ReferenceError
```
<details><summary><b>答案</b></summary>
<p>

答案: C

</p>
当我们从右侧的对象解构属性name时，我们将其值Lydia分配给名为myName的变量。

使用{name：myName}，我们是在告诉JavaScript我们要创建一个名为myName的新变量，并且其值是右侧对象的name属性的值。

当我们尝试打印name，一个未定义的变量时，就会引发`undefined`。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

105. #### 以下是个纯函数么

```js
function sum(a, b) {
  return a + b;
}
A: Yes
B: No
```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
纯函数一种若输入参数相同，则永远会得到相同输出的函数。

sum函数总是返回相同的结果。 如果我们传递1和2，它将总是返回3而没有副作用。 如果我们传递5和10，它将总是返回15，依此类推，这是纯函数的定义。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

106. #### 输出什么62

```js
const add = () => {
  const cache = {};
  return num => {
    if (num in cache) {
      return `From cache! ${cache[num]}`;
    } else {
      const result = num + 10;
      cache[num] = result;
      return `Calculated! ${result}`;
    }
  };
};

const addFunction = add();
console.log(addFunction(10));
console.log(addFunction(10));
console.log(addFunction(5 * 2));
A: Calculated! 20 Calculated! 20 Calculated! 20
B: Calculated! 20 From cache! 20 Calculated! 20
C: Calculated! 20 From cache! 20 From cache! 20
D: Calculated! 20 From cache! 20 Error

```
<details><summary><b>答案</b></summary>
<p>

答案: C

</p>
add函数是一个记忆函数。 通过记忆化，我们可以缓存函数的结果，以加快其执行速度。上述情况，我们创建一个cache对象，用于存储先前返回过的值。

如果我们使用相同的参数多次调用addFunction函数，它首先检查缓存中是否已有该值，如果有，则返回缓存值，这将节省执行时间。如果没有，那么它将计算该值，并存储在缓存中。

我们用相同的值三次调用了addFunction函数：

在第一次调用，num等于10时函数的值尚未缓存，if语句num in cache返回false，else块的代码被执行：Calculated! 20，并且其结果被添加到缓存对象，cache现在看起来像{10：20}。

第二次，cache对象包含10的返回值。 if语句 num in cache 返回true，From cache! 20被打印。

第三次，我们将5 * 2(值为10)传递给函数。 cache对象包含10的返回值。 if语句 num in cache 返回true，From cache! 20被打印。
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

107. #### 输出什么63

```js
const myLifeSummedUp = ["☕", "💻", "🍷", "🍫"]

for (let item in myLifeSummedUp) {
  console.log(item)
}

for (let item of myLifeSummedUp) {
  console.log(item)
}
A: 0 1 2 3 and "☕" "💻" "🍷" "🍫"
B: "☕" "💻" "🍷" "🍫" and "☕" "💻" "🍷" "🍫"
C: "☕" "💻" "🍷" "🍫" and 0 1 2 3
D: 0 1 2 3 and {0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}

```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
通过for-in循环，我们可以遍历一个对象自有的、继承的、可枚举的、非Symbol的属性。 在数组中，可枚举属性是数组元素的“键”， 即它们的索引。 类似于下面这个对象：

{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}

其中键则是可枚举属性，因此 0，1，2，3被记录。

通过for-of循环，我们可以迭代可迭代对象（包括 Array，Map，Set，String，arguments等）。当我们迭代数组时，在每次迭代中，不同属性的值将被分配给变量item, 因此“☕”，“💻“，”🍷”，“🍫“被打印。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

108. #### 输出什么64

```js
const list = [1 + 2, 1 * 2, 1 / 2]
console.log(list)
A: ["1 + 2", "1 * 2", "1 / 2"]
B: ["12", 2, 0.5]
C: [3, 2, 0.5]
D: [1, 1, 1]

```
<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>
数组元素可以包含任何值。 数字，字符串，布尔值，对象，数组，null，undeifned, 以及其他表达式，如日期，函数和计算。

元素将等于返回的值。 1 + 2返回3，1 * 2返回'2，'1 / 2返回0.5。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

109. #### 输出什么65

```js
function sayHi(name) {
  return `Hi there, ${name}`
}

console.log(sayHi())
A: Hi there,
B: Hi there, undefined
C: Hi there, null
D: ReferenceError

```
<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>
默认情况下，如果不给函数传参，参数的值将为undefined。 上述情况，我们没有给参数name传值。 name等于undefined，并被打印。

在ES6中，我们可以使用默认参数覆盖此默认的undefined值。 例如：

function sayHi（name =“Lydia”）{...}

在这种情况下，如果我们没有传递值或者如果我们传递undefined，name总是等于字符串Lydia
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

110. #### 输出什么66

```js
var status = "😎"

setTimeout(() => {
  const status = "😍"

  const data = {
    status: "🥑",
    getStatus() {
      return this.status
    }
  }

  console.log(data.getStatus())
  console.log(data.getStatus.call(this))
}, 0)
A: "🥑" and "😍"
B: "🥑" and "😎"
C: "😍" and "😎"
D: "😎" and "😎"

```
<details><summary><b>答案</b></summary>
<p>

 答案: B

</p>
this关键字的指向取决于使用它的位置。 在函数中，比如getStatus，this指向的是调用它的对象，上述例子中data对象调用了getStatus，因此this指向的就是data对象。 当我们打印this.status时，data对象的status属性被打印，即"🥑"。

使用call方法，可以更改this指向的对象。data.getStatus.call(this)是将this的指向由data对象更改为全局对象。在全局对象上，有一个名为status的变量，其值为”😎“。 因此打印this.status时，会打印“😎”。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

111. ####  输出什么67

```js
const person = {
  name: "Lydia",
  age: 21
}

let city = person.city
city = "Amsterdam"

console.log(person)
A: { name: "Lydia", age: 21 }
B: { name: "Lydia", age: 21, city: "Amsterdam" }
C: { name: "Lydia", age: 21, city: undefined }
D: "Amsterdam"
```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
我们将变量city设置为等于person对象上名为city的属性的值。 这个对象上没有名为city的属性，因此变量city的值为undefined。

请注意，我们没有引用person对象本身，只是将变量city设置为等于person对象上city属性的当前值。

然后，我们将city设置为等于字符串“Amsterdam”。 这不会更改person对象：没有对该对象的引用。

因此打印person对象时，会返回未修改的对象。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

112. #### 输出什么68

```js
function checkAge(age) {
  if (age < 18) {
    const message = "Sorry, you're too young."
  } else {
    const message = "Yay! You're old enough!"
  }

  return message
}

console.log(checkAge(21))
A: "Sorry, you're too young."
B: "Yay! You're old enough!"
C: ReferenceError
D: undefined
```
<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>
const和let声明的变量是具有块级作用域的，块是大括号（{}）之间的任何东西, 即上述情况if / else语句的花括号。 由于块级作用域，我们无法在声明的块之外引用变量，因此抛出ReferenceError。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

113. #### 什么样的信息将被打印

```js
fetch('https://www.website.com/api/user/1')
  .then(res => res.json())
  .then(res => console.log(res))
A: fetch方法的结果
B: 第二次调用fetch方法的结果
C: 前一个.then()中回调方法返回的结果
D: 总是undefined

```
<details><summary><b>答案</b></summary>
<p>

 答案: C

</p>
第二个.then中res的值等于前一个.then中的回调函数返回的值。 你可以像这样继续链接.then，将值传递给下一个处理程序。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

114. #### <a id="hasName_true_params"></a>  哪个选项是将hasName设置为true的方法，前提是不能将true作为参数传递

```js
fetch('https://www.website.com/api/user/1')
  .then(res => res.json())
  .then(res => console.log(res))
A: fetch方法的结果
B: 第二次调用fetch方法的结果
C: 前一个.then()中回调方法返回的结果
D: 总是undefined

```
<details><summary><b>答案</b></summary>
<p>

 答案: A

</p>
使用逻辑非运算符!，将返回一个布尔值，使用!! name，我们可以确定name的值是真的还是假的。 如果name是真实的，那么!name返回false。 !false返回true。

通过将hasName设置为name，可以将hasName设置为等于传递给getName函数的值，而不是布尔值true。

new Boolean（true）返回一个对象包装器，而不是布尔值本身。
```
new Boolean('212121')
Boolean {true}
```
name.length返回传递的参数的长度，而不是布尔值true。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

115. ####  实现一个函数判断输入是不是回文字符串

##### 题目：实现一个函数，判断输入是不是回文字符串。
<details><summary><b>答案</b></summary>
<pre>
function BackToString(str){
  if(typeof(str)!=='string')return false
  return str.split('').reverse().join('')===str
}
console.log(BackToString('abccba'))
<!-- true -->
</pre>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

116. #### <a id="stotage_single_setitem_getitem"></a> 实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem(key,value)和getItem(key)

```js
var instance = null;

class Storage {
    static getInstance() {
        if (!instance) {
            instance = new Storage();
        }
        return instance;
    }
    setItem = (key, value) => localStorage.setItem(key, value)
    getItem = key => localStorage.getItem(key)
}
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

117. #### <a id="parse_string_compute"></a> 解析字符串的值使之变成算式如‘1-10*2+1/4’（知衣科技）

当时想的是乘除等高级运算符、加减等低级运算符和数字分别放在三个数组中

先遍历高级数组进行运算操作，然后遍历低级数组进行运算操作。

方法一：使用eval函数计算字符串
```js
let str = '100+5*(120-20)'

console.log(eval(str))
```
---

[[↑] 回到顶部](#awsome-knowledge-front-end)

118. #### <a id="event"></a>  说说事件流（字节跳动）

<details><summary><b>答案</b></summary>
事件流分为两种，捕获事件流和冒泡事件流。
捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点。
冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点。
DOM事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

119. #### <a id="process_font_over_color_change"></a>  现在有一个进度条，进度条中间有一串文字，当我的进度条覆盖了文字之后，文字要与进度条反色，怎么实现

<details><summary><b>答案</b></summary>
<pre>
当时我给的是js的方案，在进度条宽度变化的时候，计算盖过每一个文字的50%，如果超过，设置文字相反颜色。
当然css也有对应的方案，也就是 mix-blend-mode，我并没有接触过。
对应html也有对应方案，也就设置两个相同位置但是颜色相反的dom结构在重叠在一起，顶层覆盖底层，最顶层的进度条取overflow为hidden，其宽度就为进度。
</pre>
</details>

---

120. #### <a id="a_b_inherit"></a> 有一个函数A和函数B请你实现B继承A分别说说他们的优缺点

<details><summary><b>答案</b></summary>
<pre>
// 方式1
function B(){}
function A(){}
B.prototype = new A();

// 方式2
function A(){}
function B(){
  A.call(this);
}

// 方式3
function B(){}
function A(){}
B.prototype = new A();

function B(){
  A.call(this);
}


方式1：简单易懂，但是无法实现多继承，父类新增原型方法/原型属性，子类都能访问到

方式2：可以实现多继承，但是只能继承父类的实例属性和方法，不能继承原型属性/方法

方式3：可以继承实例属性/方法，也可以继承原型属性/方法，但是示例了两个A的构造函数
</pre>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

121. #### <a id="描述一下this"></a>  描述一下this（有赞）

<details><summary><b>答案</b></summary>
<pre>
this：函数执行的上下文，可以通过apply，call，bind改变this的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，nodejs为global），剩下的函数调用，那就是谁调用它，this就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，this就指向哪里。
</pre>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

122. ####  图片懒加载

先将img标签的src链接设为同一张图片（比如空白图片），然后给img标签设置自定义属性（比如 data-src）,然后将真正的图片地址存储在data-src中，当JS监听到该图片元素进入可视窗口时，将自定义属性中的地址存储到src属性中。达到懒加载的效果。
这样做能防止页面一次性向服务器发送大量请求，导致服务器响应面，页面卡顿崩溃等。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="https://cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
    <style>
        .container{
            max-width: 800px;
            margin:0 auto;
        }
        .container:after{
            content:"";
            display: block;
            clear:both;
        }
        .container img{
            width:50%;
            height:260px;
            float:left;
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img4.imgtn.bdimg.com/it/u=951914923,777131061&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img1.imgtn.bdimg.com/it/u=637435809,3242058940&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img1.imgtn.bdimg.com/it/u=3990342075,2367006974&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img1.imgtn.bdimg.com/it/u=1813891576,1754763093&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img4.imgtn.bdimg.com/it/u=2539922263,2810970709&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img4.imgtn.bdimg.com/it/u=1878067600,3935137756&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img3.imgtn.bdimg.com/it/u=85690711,3884201894&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img2.imgtn.bdimg.com/it/u=3844233833,3942617167&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img0.imgtn.bdimg.com/it/u=1846695025,2515725663&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img3.imgtn.bdimg.com/it/u=346230831,1833217134&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img5.imgtn.bdimg.com/it/u=3478148120,2683867435&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img5.imgtn.bdimg.com/it/u=2298824648,1812234339&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img2.imgtn.bdimg.com/it/u=4201594846,4178139206&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img2.imgtn.bdimg.com/it/u=484389598,819397330&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img1.imgtn.bdimg.com/it/u=3729466012,914166979&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img2.imgtn.bdimg.com/it/u=354463615,3836278171&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img5.imgtn.bdimg.com/it/u=1831250492,3489827059&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img1.imgtn.bdimg.com/it/u=779005622,2247570143&fm=200&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img1.imgtn.bdimg.com/it/u=1968229118,3512711019&fm=26&gp=0.jpg">
        <img src="http://s4.sinaimg.cn/mw690/006uWPTUgy72CNFYNjB93&690" alt="1" data-src="http://img2.imgtn.bdimg.com/it/u=1088428253,1150170159&fm=200&gp=0.jpg">
    </div>

        <script>

            // 一开始没有滚动的时候，出现在视窗中的图片也会加载
            start();

            // 当页面开始滚动的时候，遍历图片，如果图片出现在视窗中，就加载图片
            var clock; //函数节流
            $(window).on('scroll',function(){
                if(clock){
                    clearTimeout(clock);
                }
                clock = setTimeout(function(){
                    start()
                },200)
            })
            
            function start(){
                 $('.container img').not('[data-isLoading]').each(function () {
                    if (isShow($(this))) {
                        loadImg($(this));
                    }
                })
            }


            // 判断图片是否出现在视窗的函数
            function isShow($node){
                return $node.offset().top <= $(window).height()+$(window).scrollTop();
            }

            // 加载图片的函数，就是把自定义属性data-src 存储的真正的图片地址，赋值给src
            function loadImg($img){
                    $img.attr('src', $img.attr('data-src'));

                    // 已经加载的图片，我给它设置一个属性，值为1，作为标识
                    // 弄这个的初衷是因为，每次滚动的时候，所有的图片都会遍历一遍，这样有点浪费，所以做个标识，滚动的时候只遍历哪些还没有加载的图片
                    $img.attr('data-isLoading',1);
            }

        </script>
</body>
</html>
```

作者：泡杯感冒灵
链接：https://www.jianshu.com/p/8e2a73638153
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

123. ####  实现页面加载进度条

网页进度条能够更好的反应当前网页的加载进度情况，loading进度条可用动画的形式从开始0%到100%完成网页加载这一过程。但是目前的浏览器并没有提供页面加载进度方面的接口，也就是说页面还无法准确返回页面实际加载的进度，本文中我们使用jQuery来实现页面加载进度条效果。

HTML

首先我们要知道的是，目前没有任何浏览器可以直接获取正在加载对象的大小。所以我们无法通过数据大小来实现0-100%的加载显示过程。

因此我们需要通过html代码逐行加载的特性，在整页代码的若干个跳跃行数中设置节点，进行大概的模糊进度反馈来实现进度加载的效果。大致意思是：页面每加载到指定区域，则返回(n)%的进度结果，通过设置多个节点，来达到一步一步显示加载进度的目的。

假如有一个页面，按区块分为页头、左侧内容、右边侧栏、页脚四部分，我们把这四部分作为四个节点，当页面加载每一个节点后，设置大概加载百分比，代码如下
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="https://cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
    <style>
        .loading {
            background: #FF6100;
            height: 5px;
            position: fixed;
            top: 0;
            z-index: 99999
        }
    </style>
</head>

<body>
    <div class="loading"></div>
    <div id="header">
        页头部分
    </div>
    <div id="mainpage">
        左侧内容
    </div>
    <div id="sider">
        右边侧栏
    </div>
    <div id="footer">
        页脚部分
    </div>

    <script type="text/javascript">
        $('.loading').animate({
            'width': '33%'
        }, 50);
        //第一个进度节点 
    </script>
    <div id="mainpage">
        左侧内容
    </div>
    <script type="text/javascript">
        $('.loading').animate({
            'width': '55%'
        }, 50);
        //第二个进度节点 
    </script>
    <div id="sider">
        右边侧栏
    </div>
    <script type="text/javascript">
        $('.loading').animate({
            'width': '80%'
        }, 50);
        //第三个进度节点 
    </script>
    <div id="footer">
        页脚部分
    </div>
    <script type="text/javascript">
        $('.loading').animate({
            'width': '100%'
        }, 50);
        //第四个进度节点 
    </script>
    <script type="text/javascript">
        $(document).ready(function () {
            $('.loading').fadeOut();
        });
    </script>
</body>

</html>
```
可以看出，没加载一个节点后，jQuery调用animate()动画方法实现进度条宽度的变化，每个节点变化以50毫秒时间让进度条看起来更流畅些，最终从0%变化到100%，完成了进度条的进度动画。
当进度条达到100%后，页面加载完成，最后还有一步要做的就是隐藏进度条。
##### 滚动进度条
未完成
```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="https://cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
    <style>
        .loading {
            background: #FF6100;
            height: 5px;
            position: fixed;
            top: 0;
            z-index: 99999
        }
        #header{
            height: 1000px;
            width: 100%;
            background-color: #FF6100;
        }
        #mainpage{
            height: 1000px;
            width: 100%;
            background-color: #FF00ff;
        }
        #sider{
            width: 100%;
            height: 1000px;
            background-color: #FFff00;
        }
        #footer{
            width: 100%;
            height: 1000px;
            background-color: #00ff00;
        }
    </style>
</head>

<body>
    <div class="loading"></div>
    <div id="header">
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分
        页头部分

    </div>
    <div id="mainpage">
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容
        左侧内容

    </div>
    <div id="sider">
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏
        右边侧栏

    </div>
    <div id="footer">
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分
        页脚部分

    </div>

    <script type="text/javascript">
        $('.loading').animate({
            'width': '33%'
        }, 50);
        //第一个进度节点 
    </script>
    <div id="mainpage">
        左侧内容
    </div>
    <script type="text/javascript">
        $('.loading').animate({
            'width': '55%'
        }, 50);
        //第二个进度节点 
    </script>
    <div id="sider">
        右边侧栏
    </div>
    <script type="text/javascript">
        $('.loading').animate({
            'width': '80%'
        }, 50);
        //第三个进度节点 
    </script>
    <div id="footer">
        页脚部分
    </div>
    <script type="text/javascript">
        $('.loading').animate({
            'width': '100%'
        }, 50);
        //第四个进度节点 
    </script>
    <script type="text/javascript">
        $(document).ready(function () {
            $('.loading').fadeOut();
        });
    </script>
</body>

</html>
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)


124. ####  事件委托

<details><summary><b>答案</b></summary>
<pre>
事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。

js中的事件委托或是事件代理详解
https://www.cnblogs.com/liugang-vip/p/5616484.html
</pre>
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

125. ####  实现extend函数

具体思路： 使用Object.defineProperty()对属性的特性进行设置，然后通过Object.getOwnPropertyDescriptor()获取到属性描述符，并赋值给新创建的对象
```js
  Object.defineProperty(Object.prototype,
        "extend",
        {
            writable: true,
            enumerable: false,
            configurable: true,
            value: function(o){
                // 获取所有的自有属性
                var names = Object.getOwnPropertyNames(o);
                for(var i =0;i< names.length;i++){
                    // 如果属性已存在则跳过
                    if(names[i] in this) continue;
                    // 获取该属性的属性描述符ss
                    var desc = Object.getOwnPropertyDescriptor(o,names[i]);
                    Object.defineProperty(this,names[i],desc)
                }
            }
        }            
    )   
```
测试
```js
// 定义一个新对象
    var a = {
        itemA: 1
    }
    // 新建一个属性，并设置属性描述符
    Object.defineProperty(a,"itemB",{
        writable: true,
        enumerable: false,
        configurable: true,
        value: 2
    })
    // 再定义一个新对象
    var b = {}
    b.extend(a)
    // 此时我们可以看到静态属性已经继承过去了
    console.log(b)  // 结果为{itemA: 1,itemB: 2}
    //再来看看属性描述符是不是也过去了
    let extendDesc = Object.getOwnPropertyDescriptor(b,"itemB")
    console.log(extendDesc)  // 结果为{value: 2, writable: true, enumerable: false, configurable: true}
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

126. #### <a id="为什么会有跨域的问题以及解决方式"></a> 为什么会有跨域的问题以及解决方式(大搜车)

<details><summary><b>答案</b></summary>
跨域跨的是域名、协议和端口

浏览器的跨域问题以及解决方案


1、为什么会有跨域问题的存在？

   JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象，即同源政策。



2、什么是同源？

   1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。
  最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页"同源"。所谓"同源"指的是"三个相同"。

  （1）协议相同

  （2）域名相同

  （3）端口相同

具体实例  比如：http://www.example.com/zw/index.html这个网站，它的协议是http://,域名是www.example.com,端口号是80(默认端口可以省略)，它的同源情况如下：

   ①、http://www.example.com/zwxk/manager.html    同源

   ②、https://www.example.com/zw/index.html   不同源（协议不同）

   ③、http://examle.com/zw/index.html  不同源(域名不同)

   ④、http://www.example.com:81zw/index.html   不同源（端口号不同）



3、同源政策的目的

同源策略的目的是为了保证用户信息的安全。防止恶意的网站盗取数据。

设想这样一个情景：A网站是一家银行，用户登录以后，又去浏览其他的网站B，如果网站B可以读取A网站的Cookie,会发生什么问题？

显然，如果Cookie包含隐私（比如存款总额），这些信息就会泄露，更可怕的是，Cookie往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒用户，为所欲为。因为浏览器同时还规定，提交表单不受同源策略的限制。

由此可见，“同源政策”的必要性，否则Cookie可以共享，互联网就毫无安全可言了。



3、非同源限制范围

    随着互联网的发展，“同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。

  （1）Cookie、LocalStorage和IndexDB无法获取。

  （2）DOM无法获得。

  （3）AJAX请求不能发送。

虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面将介绍如何规避上面三种限制。



4-1、解决跨域一：Cookie如何实现跨域

    Cookie是服务器写入浏览器的一段信息，只有同源的网页才能共享，但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共Cookie。

举例来说，A网站是:http:weibo.qq.com

  B网站是:http:lol.qq.com



那么只需设置相同的document.domain,两个网页就可共享Cookie。

document.domain = 'qq.com';
现在，A网页通过脚本设置一个Cookie。

document.Cookie = "test1=hello";
B网页就能读到这个Cookie。

var getCookie = document.cookie;
注意：这种方法只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法规避，而要使用下文将介绍的PostMessage API。

另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名,比如：.qq.com

Set-Cookie:key=value;domain=<span style="color:#cc0000;">.qq.com</span>;path=/
这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。



4-2、解决跨域问题二：如何跨域获取DOM。

如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。

   比如,父窗口运行下面的命令，如果iframe窗口不是同源将会报错。

document.getElementById("iframe").contentWindow.document
   上面命令中，父窗口想获取子窗口的DOM，应为跨源导致报错。

   反之亦然，子窗口获取主窗口的DOM也会报错。

window.parent.document.body
   如果两个窗口一级域名相同，只是二级域名不同，那么设置4-1介绍的document.domain属性，就可规避同源政策，拿到DOM。

   对于完全不相同的网站，目前有三种方法，可以解决跨域窗口的通信问题。

   (1)片段识别符（fragment identifier）

   (2)window.name

   (3)跨文档通信API（Cross-document messaging）



 4-2-1：片段识别符

     片段识别符指的是，URL的#号后面的部分，比如http://qq.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面将不会重新刷新、

  父窗口可以把信息，写入子窗口的片段标识符。

 var src = originURL+'#'+data;
 document.getElementById('iframe').src = src;
  子窗口通过监听hashchange事件得到通知

  window.onhashchange = checkMessage;
  function checkMessage(){
  var message = window.location.hash;
  //...
 }
 同样的，子窗口也可以改变父窗口的片段标识符。

  parent.location.href = target+"#"+hash;
4-2-2:window.name:

浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置这个属性，后一个网页就可以读取它。

父窗口先发开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。

window.name = data;
接着，子窗口跳回一个与主窗口同域的网址。


location = 'http://parent.url.com/xxx.html';
  然后，主窗口就可以读取子窗口的window.name了。

var data = document.getElementById('iframe').contentWindow.name;
优点：window.name容量很大，可以防止非常长的字符串；
缺点：必须监听子窗口window.name属性的变化，会影响网页性能。



4-2-3:跨文档消息传输window.postMessage：

上面两种方法都属于破解，HTML5为解决这个问题，引入一个全新的API：跨文档消息传输Cross Document Messaging。

下一代浏览器都将支持这个功能:Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 

Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。



使用方法：otherWindow.postMessage(message, targetOrigin);

otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性;window.open的返回值；

通过name或下标从window.frames取到的值。

message: 具体的信息内容，string类型。

targetOrigin: 接受消息的窗口的源(origin)，即“协议+域名+端口”。也可以设为“*”，表示不限制域名，向所有窗口发送。

message事件的事件对象event，提供一下三个属性:

(1).event.source:发送消息的窗口

(2).event.origin:消息发向的网站

(3).event.data:消息内容

具体实例：

a.com/index.html中的代码：
```html
<iframe id="ifr" src="b.com/index.html"></iframe>
<script type="text/javascript">
window.onload = function() {
    var ifr = document.getElementById('ifr');
    var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样
                                        // 若写成'http://c.com'就不会执行postMessage了
    ifr.contentWindow.postMessage('I was there!', targetOrigin);
};
</script>
b.com/index.html中的代码：

<script type="text/javascript">
    window.addEventListener('message', function(event){
        // 通过origin属性判断消息来源地址
        if (event.origin == 'http://a.com') {
            alert(event.data);    // 弹出"I was there!"
            alert(event.source);  // 对a.com、index.html中window对象的引用
                                  // 但由于同源策略，这里event.source不可以访问window对象
        }
    }, false);
</script>

```
4-3、如何解决跨域LocalStorage。

通过window.postMessage,读写其他窗口的LocalStorage也成为了可能。下面是一个例子，主窗口写入iframe子窗口的LocalStorage。

window.onmessage = function(e){
  if(e.origin !== 'http://bbb.com'){
    return ;
 }
  var payload = JSON.parse(e.data);
  localStorage.setItem(payload.key,JSON.stringify(payload.data));
};
上面代码中，子窗口将父窗口发送来的消息，写入自己的LocalStorage。

父窗口发送消息的代码如下.

var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = {name:'Jack'};
win.postMessage(JSON.stringify({key:'storage',data:obj}),'http://bbb.com');
加强版的子窗口接受消息的代码如下。

window.onmessage = function(e) {
  if (e.origin !== 'http://bbb.com') return;
  var payload = JSON.parse(e.data);
  switch (payload.method) {
    case 'set':
      localStorage.setItem(payload.key, JSON.stringify(payload.data));
      break;
    case 'get':
      var parent = window.parent;
      var data = localStorage.getItem(payload.key);
      parent.postMessage(data, 'http://aaa.com');
      break;
    case 'remove':
      localStorage.removeItem(payload.key);
      break;
  }
};
加强版的父窗口发送消息代码如下:

var win = document.getElementsByTagName('iframe')[0].contentWindow;
var obj = { name: 'Jack' };
// 存入对象
win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');
// 读取对象
win.postMessage(JSON.stringify({key: 'storage', method: "get"}), "*");
window.onmessage = function(e) {
  if (e.origin != 'http://aaa.com') return;
  // "Jack"
  console.log(JSON.parse(e.data).name);
};

4-4、如何解决AJAX的跨域：

同源政策规定，AJAX请求只能发给同源的网址，否则就报错。
除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。

（1）JSONP

（2）WebSocket

（3）CORS



————————————————
版权声明：本文为CSDN博主「Topepy」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u013084331/article/details/51114288

</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)



127. ####  jsonp原理postMessage原理

<details><summary><b>答案</b></summary>

```text
很简单，就是利用<script>标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个<script>元素，地址指向第三方的API网址，形如：     <script src="http://www.example.net/api?param1=1&param2=2"></script>     并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。     第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：     callback({"name":"hax","gender":"Male"})     这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。    补充：“历史遗迹”的意思就是，如果在今天重新设计的话，也许就不会允许这样简单的跨域了嘿，比如可能像XHR一样按照CORS规范要求服务器发送特定的http头。

作者：贺师俊
链接：https://www.zhihu.com/question/19966531/answer/13502030
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

1. PostMessage的运行机制

PostMessage函数发送消息，不等待消息处理完成，立刻返回。稍微深入一点，PostMessage只管发送消息，消息有没有被送到则并不关心，只要发送了消息，便立刻返回。

2. PostMessage的运行内幕

PostMessage函数将一个消息放入与创建这个窗口的消息队列相关的线程中，并立刻返回不等待线程处理消息。

3. PostMessage的内部实现
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)



128. ####  实现拖拽功能比如把5个兄弟节点中的最后一个节点拖拽到节点1和节点2之间

<details><summary><b>答案</b></summary>

</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)


129. ####  动画setTimeout何时执行requestAnimationFrame的优点

<details><summary><b>答案</b></summary>
在到期时间(delay毫秒)之后执行

window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行

注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()
当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的<iframe> 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。

回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

130. #### <a id="parseint_no_number"></a> 手写parseInt的实现：要求简单一些，把字符串型的数字转化为真正的数字即可，但不能使用JS原生的字符串转数字的API，比如Number

<details><summary><b>答案</b></summary>
<pre>
function _parseInt(str, radix) {
 let str_type = typeof str;
 let res = 0;
 if (str_type !== 'string' && str_type !== 'number') {
  // 如果类型不是 string 或 number 类型返回NaN
  return NaN
 }
 
 // 字符串处理
 str = String(str).trim().split('.')[0]
 let length = str.length;
 if (!length) {
  // 如果为空则返回 NaN
  return NaN
 }
 
 if (!radix) {
  // 如果 radix 为0 null undefined
  // 则转化为 10
  radix = 10;
 }
 if (typeof radix !== 'number' || radix < 2 || radix > 36) {
  return NaN
 }
 
 for (let i = 0; i < length; i++) {
  let arr = str.split('').reverse().join('');
  res += Math.floor(arr[i]) * Math.pow(radix, i)
 }
 
 return res;
}
</pre>
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

131. ####  编写分页器组件的时候为了减少服务端查询次数点击下一页怎样能确保还有数据可以加载请求数据不会为空

编写分页器组件的时候，为了减少服务端查询次数，点击“下一页”怎样能确保还有数据可以加载（请求数据不会为空）？
<details><summary><b>答案</b></summary>
后端每次查询完之后,给你个标记,hasMore true 就还有 false 就说明这是最后一页了,如果针对那种列表总数可变的情况,就只能根据total 来判断了
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

132. #### <a id="es6_feature"></a>  ES6新增了哪些特性使用过哪些也有当场看代码说输出结果的

<details><summary><b>答案</b></summary>
Let和const关键字

变量的解构赋值

字符串，数值的扩展

数组，对象的扩展

函数的扩展

for...of
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

133. ####  JS模块化的实践

<details><summary><b>答案</b></summary>
模块化开发是 JS 项目开发中的必备技能，它如同面向对象、设计模式一样，可以兼顾提升软件项目的可维护性和开发效率。模块之间通常以全局对象维系通讯。在小游戏中，GameGlobal 是全局对象。在小程序中，App 是全局对象，任何页面都可以使用 getApp() 获取这个全局对象。在 NodeJS 中，global 是全局对象。在传统浏览器宿主中，window 是全局对象。

作者：石桥码农
链接：https://www.jianshu.com/p/79b0d01a6f47
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

134. ####  requirejs的实现原理如果使用过webpack进一步会问两者打包的异同及优缺点

  require.js的实现原理（如果使用过webpack，进一步会问，两者打包的异同及优缺点）
<details><summary><b>答案</b></summary>
　　requirejs 加载模块的核心思想是利用了动态加载脚本的异步性以及 onload 事件以毒攻毒，关于脚本的加载，我们需要注意一下几点：

　　在 HTML 中引入 <script> 标签是同步加载；
　　在脚本中动态加载是异步加载，且由于被加载的脚本在事件队列的后端，因此总是会在当前脚本之后执行；
　　使用 onload 和 onerror 事件可以监听脚本加载完成，以异步的事件来处理异步的事件；


从 RequireJs 源码剖析脚本加载原理
https://blog.csdn.net/ai52011/article/details/77113611
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

136. ####  实现gulp的功能

<details><summary><b>答案</b></summary>

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

137. ####  使用前端框架angularvuereact带来哪些好处相对于使用jQuery

使用前端框架（angular/vue/react）带来哪些好处，相对于使用jQuery
<details><summary><b>答案</b></summary>
前者是数据驱动，写出的代码模块化。后者是会频繁操作DOM，写出面条式的代码
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

138. ####  vue双向数据绑定的实现

<details><summary><b>答案</b></summary>
类似于设计模式中的观察者模式
我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性上发生变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：

1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。

3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

139. ####  单页应用如何实现其路由功能

<details><summary><b>答案</b></summary>
　　目前来说，无论是vue，还是react，spa的路由实现方式无非就是以下两者：

hash方式。 使用location.hash和hashchange事件实现路由。 
history api。使用html5的history api实现，主要就是popState事件等。
　　hash用的还是比较多的，但是这种方式的url会比较丑陋，会出现 #； 而history api就可以很好的解决这个问题，但是需要后端配置，并且由于是html5中的api，所以兼容性还不是很好，用的时候需要确定你的用户，再做决定。
</details>


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

140. ####  手动实现callapplybind

<details><summary><b>答案</b></summary>


##### 模拟实现call

需要注意的是apply接受的参数是函数或者对象


1. 判断this是否是函数，防止`Function.prototype.mycall()`直接调用

2. content为可选参数，上下文，如果不传的话，content就为window全局对象

3. 为content创建一个Symbol属性，将当前函数赋值给这个属性fn

4. 处理参数，传入第1个参数之后的所有参数

5. 删除content的fn属性

6. 返回res

```js

Function.prototype.myCall = function (content = window, ...args) {
    if (this === Function.prototype) {
        return undefined
    }
    content = content || window
    const fn = Symbol()
    content[fn] = this
    let res = content[fn](...args)
    delete content[fn]
    return res
}

// 测试

function Shout(name, place) {
    this.name = name
    this.place = place
}

function Animal(name, place, age) {
    Shout.myCall(this, name, place)
    this.age = age
}

let dog = new Animal('xiaowang', 'tree', 1)

console.log(dog.name, dog.place, dog.age)
// xiaowang tree 1

```

##### 模拟实现apply

需要注意的是apply接受的参数是数组

```js
Function.prototype.myApply = function (content = window, ...args) {
    if (this === Function.prototype) {
        return undefined
    }
    content = content || window
    const fn = Symbol()
    content[fn] = this
    let res
    if (Array.isArray(...args)) {
        res = content[fn](...args)
    } else {
        res = content[fn]()
    }
    delete content[fn]
    return res
}

// 测试

let Shout = ['xiangwang', 'tree']
let Animal = ['1', '2']
Shout.push.myApply(Shout, Animal)
console.log(Shout)
// [ 'xiangwang', 'tree', [ '1', '2' ] ]
```
##### 模拟实现bind

1. 先判断this是否是Function.prototype,防止被其调用

2. 处理参数，返回一个闭包

3. 判断是否为构造函数调用，如果是则使用new调用当前函数，如果不是则使用apply，将content和处理好的参数传入
```js

Function.prototype.myBind = function (content, ...args1) {
    if (this === Function.prototype) {
        throw new TypeError('error')
    }
    let self = this
    return function fn(...args2) {
         // 判断是否用于构造函数
        if (this instanceof fn) {
            return new self(...args1, ...args2)
        }
        return self.apply(content, args1.concat(args2))
    }
}

// 测试

var module = {
    x: 42,
    getX: function () {
        return this.x;
    }
}

var unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined

var boundGetX = unboundGetX.myBind(module);
console.log(boundGetX());
// expected output: 42
```

##### 扩展
参数argument和args的区别

```js
    // 获取argument对象 类数组对象 不能调用数组方法
    function test1() {
        console.log('获取argument对象 类数组对象 不能调用数组方法', arguments);
        // arguments.push(1)
        // TypeError: arguments.push is not a function
    }

    // 获取参数数组  可以调用数组方法
    function test2(...args) {
        // args.push(1)
        // [ 1, 2, 3, 1 ]
        console.log('获取参数数组  可以调用数组方法', args);
    }

    // 获取除第一个参数的剩余参数数组
    function test3(first, ...args) {
        console.log('获取argument对象 类数组对象 不能调用数组方法', first, args);
    }

    // 遗传参数
    function test4(first, ...args) {
        fn(...args);
        fn(...arguments);
    }

    function fn() {
        console.log('遗传', ...arguments);
    }

    test1(1, 2, 3);
    test2(1, 2, 3);
    test3(1, 2, 3);
    test4(1, 2, 3);
```
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

141. #### 观察者模式

<details><summary><b>答案</b></summary>

就类似于在某虎直播平台上订阅了某某主播，你不需要隔三差五去上平台瞧瞧那货开播了没。只要订阅了，他开播平台就会向你发布开播信息。这就是一个栗子。

##### 优点

1. 可以代替我们传统的回调函数
2. 不需要关注对象在异步执行阶段的内部状态，只需要关心事件的终点
3. 取代对象之间硬编码通知机制，一个对象不必显式调用另一个对象的接口，而是松耦合的联系在一起 。

##### Nodejs的EventEmitter
1. 
nodejs的events模块只提供一个对象：events.EventEmitter。它的核心就是事件触发与事件监听器功能的封装。

> Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。

2. Api
addListener(event, listener)

为指定事件添加一个监听器，默认添加到监听器数组的尾部。

removeListener(event, listener)

移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。

setMaxListeners(n)

默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。

once(event, listener)

为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。

emit(event, [arg1], [arg2], [...])

按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。


3. 基本使用

```js
var events = require('events');
var eventEmitter = new events.EventEmitter();

// 监听器 #1
var listener1 = function listener1() {
   console.log('监听器 listener1 执行。');
}

// 监听器 #2
var listener2 = function listener2() {
  console.log('监听器 listener2 执行。');
}

// 绑定 connection 事件，处理函数为 listener1 
eventEmitter.addListener('connection', listener1);

// 绑定 connection 事件，调用一次，处理函数为 listener2
eventEmitter.once('connection', listener2);

// 处理 connection 事件 
eventEmitter.emit('connection');

// 处理 connection 事件 
eventEmitter.emit('connection');
```

##### 手动实现EventEmitter
```js
    function EventEmitter() {
      this._maxListeners = 10;
      this._events = Object.create(null);
    }

    // 向事件队列添加事件
    // prepend为true表示向事件队列头部添加事件
    EventEmitter.prototype.addListener = function (type, listener, prepend) {
      if (!this._events) {
        this._events = Object.create(null);
      }
      if (this._events[type]) {
        if (prepend) {
          this._events[type].unshift(listener);
        } else {
          this._events[type].push(listener);
        }
      } else {
        this._events[type] = [listener];
      }
    };

    // 移除某个事件
    EventEmitter.prototype.removeListener = function (type, listener) {
      if (Array.isArray(this._events[type])) {
        if (!listener) {
          delete this._events[type]
        } else {
          this._events[type] = this._events[type].filter(e => e !== listener && e.origin !== listener)
        }
      }
    };

    // 向事件队列添加事件，只执行一次
    EventEmitter.prototype.once = function (type, listener) {
      const only = (...args) => {
        listener.apply(this, args);
        this.removeListener(type, listener);
      }
      only.origin = listener;
      this.addListener(type, only);
    };

    // 执行某类事件
    EventEmitter.prototype.emit = function (type, ...args) {
      if (Array.isArray(this._events[type])) {
        this._events[type].forEach(fn => {
          fn.apply(this, args);
        });
      }
    };

    // 设置最大事件监听个数
    EventEmitter.prototype.setMaxListeners = function (count) {
      this.maxListeners = count;
    };
```
测试代码：
```js
  var emitter = new EventEmitter();

    var onceListener = function (args) {
      console.log('我只能被执行一次', args, this);
    }

    var listener = function (args) {
      console.log('我是一个listener', args, this);
    }

    emitter.once('click', onceListener);
    emitter.addListener('click', listener);

    emitter.emit('click', '参数');
    emitter.emit('click');

    emitter.removeListener('click', listener);
    emitter.emit('click');
```
##### JavaScript自定义事件

DOM也提供了类似上面EventEmitter的API，基本使用：

```js
//1、创建事件
var myEvent = new Event("myEvent");

//2、注册事件监听器
elem.addEventListener("myEvent",function(e){
  
})

//3、触发事件
elem.dispatchEvent(myEvent);

```

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

142. #### 浅拷贝和深拷贝

<details><summary><b>答案</b></summary>
关于为什么会有深拷贝和浅拷贝，实际上就是基本类型和引用类型的问题。

##### 浅拷贝

我们用很多简单的方法都能实现浅拷贝

```js
arr.slice()
arr.concat()
```
##### 深拷贝
我们也能用简单的方法实现深拷贝
```js
JSON.parse(JSON.stringify(obj))
```
手动实现

```js
const mapTag = '[object Map]';
const setTag = '[object Set]';
const arrayTag = '[object Array]';
const objectTag = '[object Object]';
const argsTag = '[object Arguments]';

const boolTag = '[object Boolean]';
const dateTag = '[object Date]';
const numberTag = '[object Number]';
const stringTag = '[object String]';
const symbolTag = '[object Symbol]';
const errorTag = '[object Error]';
const regexpTag = '[object RegExp]';
const funcTag = '[object Function]';

const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];


function forEach(array, iteratee) {
    let index = -1;
    const length = array.length;
    while (++index < length) {
        iteratee(array[index], index);
    }
    return array;
}

function isObject(target) {
    const type = typeof target;
    return target !== null && (type === 'object' || type === 'function');
}

function getType(target) {
    return Object.prototype.toString.call(target);
}

function getInit(target) {
    const Ctor = target.constructor;
    return new Ctor();
}

function cloneSymbol(targe) {
    return Object(Symbol.prototype.valueOf.call(targe));
}

function cloneReg(targe) {
    const reFlags = /\w*$/;
    const result = new targe.constructor(targe.source, reFlags.exec(targe));
    result.lastIndex = targe.lastIndex;
    return result;
}

function cloneFunction(func) {
    const bodyReg = /(?<={)(.|\n)+(?=})/m;
    const paramReg = /(?<=\().+(?=\)\s+{)/;
    const funcString = func.toString();
    if (func.prototype) {
        const param = paramReg.exec(funcString);
        const body = bodyReg.exec(funcString);
        if (body) {
            if (param) {
                const paramArr = param[0].split(',');
                return new Function(...paramArr, body[0]);
            } else {
                return new Function(body[0]);
            }
        } else {
            return null;
        }
    } else {
        return eval(funcString);
    }
}

function cloneOtherType(targe, type) {
    const Ctor = targe.constructor;
    switch (type) {
        case boolTag:
        case numberTag:
        case stringTag:
        case errorTag:
        case dateTag:
            return new Ctor(targe);
        case regexpTag:
            return cloneReg(targe);
        case symbolTag:
            return cloneSymbol(targe);
        case funcTag:
            return cloneFunction(targe);
        default:
            return null;
    }
}

function clone(target, map = new WeakMap()) {

    // 克隆原始类型
    if (!isObject(target)) {
        return target;
    }

    // 初始化
    const type = getType(target);
    let cloneTarget;
    if (deepTag.includes(type)) {
        cloneTarget = getInit(target, type);
    } else {
        return cloneOtherType(target, type);
    }

    // 防止循环引用
    if (map.get(target)) {
        return target;
    }
    map.set(target, cloneTarget);

    // 克隆set
    if (type === setTag) {
        target.forEach(value => {
            cloneTarget.add(clone(value));
        });
        return cloneTarget;
    }

    // 克隆map
    if (type === mapTag) {
        target.forEach((value, key) => {
            cloneTarget.set(key, clone(value));
        });
        return cloneTarget;
    }

    // 克隆对象和数组
    const keys = type === arrayTag ? undefined : Object.keys(target);
    forEach(keys || target, (value, key) => {
        if (keys) {
            key = value;
        }
        cloneTarget[key] = clone(target[key], map);
    });

    return cloneTarget;
}


// 测试
let A = {
    a: 'a'
}
let B = clone(A)
console.log(B)
A.a = "b"
console.log(A)
console.log(B)
```


我们了解了对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个情况。

let a = {
  age: 1
}
let b = a
a.age = 2
console.log(b.age) // 2
浅拷贝
首先可以通过 Object.assign 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。

let a = {
  age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
另外我们还可以通过展开运算符 ... 来实现浅拷贝

let a = {
  age: 1
}
let b = { ...a }
a.age = 2
console.log(b.age) // 1
通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了

let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = { ...a }
a.jobs.first = 'native'
console.log(b.jobs.first) // native
浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。

深拷贝

这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。

let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
但是该方法也是有局限性的：

会忽略 undefined
会忽略 symbol
不能序列化函数
不能解决循环引用的对象
let obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  },
}
obj.c = obj.b
obj.e = obj.a
obj.b.c = obj.c
obj.b.d = obj.b
obj.b.e = obj.b.c
let newObj = JSON.parse(JSON.stringify(obj))
console.log(newObj)
如果你有这么一个循环引用对象，你会发现并不能通过该方法实现深拷贝


在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化

let a = {
  age: undefined,
  sex: Symbol('male'),
  jobs: function() {},
  name: 'yck'
}
let b = JSON.parse(JSON.stringify(a))
console.log(b) // {name: "yck"}
你会发现在上述情况中，该方法会忽略掉函数和 undefined 。

但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题。

如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel

function structuralClone(obj) {
  return new Promise(resolve => {
    const { port1, port2 } = new MessageChannel()
    port2.onmessage = ev => resolve(ev.data)
    port1.postMessage(obj)
  })
}

var obj = {
  a: 1,
  b: {
    c: 2
  }
}

obj.b.d = obj.b

// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () => {
  const clone = await structuralClone(obj)
  console.log(clone)
}
test()
当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 lodash 的深拷贝函数。

function deepClone(obj) {
  function isObject(o) {
    return (typeof o === 'object' || typeof o === 'function') && o !== null
  }

  if (!isObject(obj)) {
    throw new Error('非对象')
  }

  let isArray = Array.isArray(obj)
  let newObj = isArray ? [...obj] : { ...obj }
  Reflect.ownKeys(newObj).forEach(key => {
    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
  })

  return newObj
}

let obj = {
  a: [1, 2, 3],
  b: {
    c: 2,
    d: 3
  }
}
let newObj = deepClone(obj)
newObj.b.c = 1
console.log(obj.b.c) // 2


</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

143. #### 数组去重

<details><summary><b>答案</b></summary>

最后一个方法有点问题
```js
// test
let arr = [1, 2, 3, 1, 2, 3, 1]

// Set
let res = [...new Set(arr)]
console.log(res)
// [ 1, 2, 3 ]

let res2 = Array.from(new Set(arr))
console.log(res2)
// [ 1, 2, 3 ]

// Object
let unique = (arr) => {
    var container = {}
    return arr.filter((item, index) => container.hasOwnProperty(item) ? false : (container[item] = true))
}
let res3 = unique(arr)
console.log(res3)
// [ 1, 2, 3 ]

// indexOf+filter
let unique2 = (arr) => arr.filter((item, index) => arr.indexOf(item) === index)
let res4 = unique2(arr)
console.log(res4)
// [ 1, 2, 3 ]

// 排序后左右对比去重
let sort = (a, b) => {
    return a - b
}
let middleArr = arr.sort()
let res5 = []
for (let i = 0; i < middleArr.length; i++) {
    if (middleArr[i] !== middleArr[i + 1]) {
        res5.push(middleArr[i])
    }

}
console.log(res5)
// [ 1, 2, 3 ]


// filter+indexOf+lastIndexOf前后去重
let res6 =arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i))
console.log(res6)
// []

```

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

144.   #### 如何实现一个倒计时功能类似于蘑菇街中的秒杀

如何实现一个倒计时功能，类似于蘑菇街中的秒杀（蘑菇街）
<details><summary><b>答案</b></summary>

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

145.   #### <a id="es6_this_function_this"></a> 怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢？（蘑菇街）

<details><summary><b>答案</b></summary>

普通函数中的this:

1. this总是代表它的直接调用者, 例如 obj.func ,那么func中的this就是obj

2. 在默认情况(非严格模式下,未使用 'use strict'),没找到直接调用者,则this指的是 window

3. 在严格模式下,没有直接调用者的函数中的this是 undefined

4. 使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象

箭头函数中的this

默认指向在定义它时,它所处的对象,而不是执行时的对象, 定义它的时候,可能环境是window（即继承父级的this）;

下面通过一些例子来研究一下 this的一些使用场景

[ES6中箭头函数与普通函数this的区别](https://www.cnblogs.com/freelyflying/p/6978126.html)
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

146.   #### 说一下同源策略

说一下同源策略（蘑菇街）
<details><summary><b>答案</b></summary>
同源策略，它是由Netscape提出的一个著名的安全策略。

现在所有支持JavaScript 的浏览器都会使用这个策略。

所谓同源是指，域名，协议，端口相同。

当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面

当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，

即检查是否同源，只有和百度同源的脚本才会被执行。

如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)


147.   #### <a id="dom_two_node"> 一个DOM树，其中有两个节点，找出这两个节点公共的父节点？ (有赞)

<details><summary><b>答案</b></summary>
这个问题可以分为三种情况来考虑：

```
情况一：root未知，但是每个节点都有parent指针
此时可以分别从两个节点开始，沿着parent指针走向根节点，得到两个链表，然后求两个链表的第一个公共节点，这个方法很简单，不需要详细解释的。

情况二：节点只有左、右指针，没有parent指针，root已知
思路：有两种情况，一是要找的这两个节点（a, b），在要遍历的节点（root）的两侧，那么这个节点就是这两个节点的最近公共父节点；
二是两个节点在同一侧，则 root->left 或者 root->right 为 NULL，另一边返回a或者b。那么另一边返回的就是他们的最小公共父节点。
递归有两个出口，一是没有找到a或者b，则返回NULL；二是只要碰到a或者b，就立刻返回。
// 二叉树结点的描述  
typedef struct BiTNode  
{  
    char data;  
    struct BiTNode *lchild, *rchild;      // 左右孩子  
}BinaryTreeNode; 
// 节点只有左指针、右指针，没有parent指针，root已知
BinaryTreeNode* findLowestCommonAncestor(BinaryTreeNode* root , BinaryTreeNode* a , BinaryTreeNode* b)
{
	if(root == NULL)
		return NULL;
	if(root == a || root == b)
		return root;
	BinaryTreeNode* left = findLowestCommonAncestor(root->lchild , a , b);
	BinaryTreeNode* right = findLowestCommonAncestor(root->rchild , a , b);
	if(left && right)
		return root;
	return left ? left : right;
}

情况三： 二叉树是个二叉查找树，且root和两个节点的值(a, b)已知
// 二叉树是个二叉查找树，且root和两个节点的值(a, b)已知
BinaryTreeNode* findLowestCommonAncestor(BinaryTreeNode* root , BinaryTreeNode* a , BinaryTreeNode* b)
{
	char min  , max;
	if(a->data < b->data)
		min = a->data , max = b->data;
	else
		min = b->data , max = a->data;
	while(root)
	{
		if(root->data >= min && root->data <= max)
			return root;
		else if(root->data < min && root->data < max)
			root = root->rchild;
		else
			root = root->lchild;
	}
	return NULL;
}
```

版权声明：本文为CSDN博主「hackbuteer1」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/hackbuteer1/article/details/8022138

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

148. #### <a id="strong_cache_negotiate_cache"></a> 说一下强缓存和协商缓存？ （浏览器的缓存机制也需要很清楚） (有赞) 

<details><summary><b>答案</b></summary>
浏览器的协商缓存与强缓存
2017-04-0710841View0
做前端有两个比较令人头痛的事，一个是命名，另一个就是缓存了。缓存的问题在移动端上尤其严重，因为手机随时随地会缓存你的资源，要想清缓存，不像PC使用强制刷新，还要手动找到浏览器的缓存，有时候还要重启等。下面这篇文章清晰的讲解关注浏览器的缓存，值得看看。

什么是浏览器缓存
浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。

浏览器缓存的优点有：

减少了冗余的数据传输，节省了网费
减少了服务器的负担，大大提升了网站的性能
加快了客户端加载网页的速度
在前端开发面试中，浏览器缓存是web性能优化面试题中很重要的一个知识点，从而说明浏览器缓存是提升web性能的一大利器，但是浏览器缓存如果使用不当，也会产生很多问题，正所谓是，想说爱你，并不是很容易的事。所以，结合最近遇到的案例，本文对浏览器缓存相关的知识进行总结归纳，希望对读者有所帮助。

浏览器缓存的分类
浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。

浏览器在第一次请求发生后，再次请求时：

浏览器会先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；
如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容
强缓存
强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。

Expires
该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。

Cache-Control
Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：

no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。
private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。
Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。

协商缓存
协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。

Last-Modify/If-Modify-Since

浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。

当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。

如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。

ETag/If-None-Match

与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。

与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。

为什么要有Etag

你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
某些服务器不能精确的得到文件的最后修改时间。
Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

强缓存与协商缓存的区别可以用下表来表示：

缓存类型	获取资源形式	状态码	发送请求到服务器
强缓存	从缓存取	200（from cache）	否，直接从缓存取
协商缓存	从缓存取	304（Not Modified）	否，通过服务器来告知缓存是否可用
用户行为对缓存的影响
用户操作	Expires/Cache-Control	Last-Modied/Etag
地址栏回车	有效	有效
页面链接跳转	有效	有效
新开窗口	有效	有效
前进回退	有效	有效
F5刷新	无效	有效
Ctrl+F5强制刷新	无效	无效
实际问题分析
如文章开头所属，代码更新到线上后用户浏览器不能自行更新，我们不能要求客户在系统更新后都进行一次缓存清理的操作。

到底该如何解决呢？

在资源请求的URL中增加一个参数，比如：js/mian.js?ver=0.7.1。这个参数是一个版本号，每一次部署的时候变更一下，当这个参数变化的时候，强缓存都会失效并重新加载。这样一来，静态资源，部署以后就需要重新加载。这样就比较完美的解决了问题。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

149. #### 为什么数据库使用的是mongodb而不是mysql

为什么数据库使用的是mongodb而不是mysql (有赞)
<details><summary><b>答案</b></summary>
过去几年，使用NoSQL数据库的网站和应用数量激增。 MongoDB无处不在。 现代网络如何偏离传统的基于SQL的数据库确实令人着迷。 MongoDB和其他NoSQL数据库在存储和检索数据方面有一种新方法。 那么让我们来看看MongoDB与MySQL不同的一些关键因素。

MongoDB 与 MySQL，你选择谁？

数据建模

使用像MySQL这样的传统SQL数据库，我们需要一个固定的数据结构。 我们希望知道将记录哪些不同类型的数据。 我们必须事先创建数据库，必需的表，列，甚至为每列指定数据类型。 MongoDB不是这种情况。 使用MongoDB，开发人员可以稍微悠闲一点。 忘记表和数据类型，甚至不需要创建数据库。 MongoDB会自动为您完成大部分初始繁重工作。

MongoDB致力于集合的思想。 这些集合类似于表，但没有任何固定数量的列。 因此，集合中的每个文档（文档是行/记录的MySQL等价物）可以具有不同的结构。 它们可能具有相同数量的字段，也可能不具有相同数量的字段（字段是MySQL的等效列）。 因此可以说MySQL具有固定模式，而MongoDB具有灵活的模式。

搜索数据

在MySQL中搜索数据库中的数据可能是一项非常简单的任务。我们支持诸如可以帮助组合来自多个表的数据的连接之类的东西。但这再次要求您非常了解您的数据模型。像外键这样的概念允许您在不同数据集之间创建关系。这有助于保持数据完整性。

由于其灵活的架构，MongoDB在搜索数据方面有着截然不同的方法。搜索数据非常有限，因为Mongo中没有联接。由于允许嵌套，因此您需要在一个文档中放置所需的任何数据。这是真正困扰在mongo上工作的新开发人员的事情之一。总的来说，我会说SQL在搜索数据方面非常丰富而且MongoDB非常有限。

约束和数据完整性

由于您必须使用SQL预定义数据模型，因此无需担心完整性。数据库不接受任何不符合标准的数据类型。像外键，主键和唯一索引这样的约束会让开发人员感到很麻烦。

另一方面，尽管MongoDB落后了。它确实提供了几种类型的基于完整性的索引，包括唯一索引，但是数据类型没有约束。它完全被理解，因为这些领域本身并没有固定。因此，非常常见的是，ORM（对象关系映射器）经常与MongoDB一起使用。它们用于对服务器端代码执行完整性检查。总而言之，SQL是非常严格且丰富的数据完整性，而MongoDB则不然。

扩展

每个成功的应用程序都需要在某个时候扩展。当用户数量增长时，需要多个服务器。这是能够扩展的因素。传统上，SQL数据库是为垂直扩展而构建的，即通​​过增加同一台机器上的硬件进行扩展。如果该服务器由于某种原因崩溃，这将导致麻烦。

另一方面，MongoDB是为了水平扩展而构建的。您可以设置多个节点，这些节点将自动复制，没有单点故障。虽然MySQL已经看到了MySQL Cluster的巨大改进，但它仍然无法与MongoDB相媲美。在扩展方面，MongoDB的性能远远优于MySQL。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

150. #### 什么是xss如何防止xss

什么是xss，如何防止xss？ (有赞)
前端安全】JavaScript防XSS攻击
什么是XSS

XSS（Cross Site Scripting），跨站脚本攻击，是一种允许攻击者在另外一个用户的浏览器中执行恶意代码脚本的脚本注入式攻击。本来缩小应该是CSS，但为了和层叠样式（Cascading Style Sheet,CSS）有所区分，故称XSS。

对于攻击者来说，能够让受害者浏览器执行恶意代码的唯一方式，就是把代码注入到受害者从网站下载的网页中。

xss攻击的种类

1、持续型XSS攻击：恶意脚本来源于网站的数据库

我们来看这种攻击的一个场景

 

1、攻击者通过评论表单提交将`<script>alert(‘aaa’)</script>`提交到网站

2、网站后端对提交的评论数据不做任何操作，直接存储到数据库中

3、其他用户访问正常访问网站，并且需要请求网站的评论数据

4、网站后端会从数据库中取出数据，直接返回给用户

5、用户得到页面后，直接运行攻击者提交的代码`<script>alert(‘aaa’)</script>`，所有用户都会在网页中弹出aaa的弹窗

这种攻击方式恶意代码会被存储在数据库中，其他用户在正常访问的情况下，也有会被攻击，影响的范围比较大

2、反射型XSS攻击：恶意脚本来源于受害者的请求

在一个反射型XSS攻击中，恶意文本属于受害者发送给网站的请求中的一部分。随后网站又把恶意文本包含进用于响应用户的返回页面中，发还给用户。

我们来看下面这个场景

 

1、用户误点开了带攻击的url :`http://xxx?keyword=<script>alert('aaa')</script>`

2、网站给受害者的返回中包含了来自URL的的恶意文本

3、用户的浏览器收到文本后执行页面，会在网页中弹窗aaa

反射型的攻击需要用户主动的去访问带攻击的链接，攻击者可以通过邮件或者短信的形式，诱导受害者点开链接。如果攻击者配合短链接URL，攻击成功的概率会更高

3、基于DOM的XSS攻击

基于DOM的XSS攻击是反射型攻击的变种。服务器返回的页面是正常的，只是我们在页面执行js的过程中，会把攻击代码植入到页面中

下面展示的是这种攻击的场景

 

1、用户误点开了带攻击的url :`http://xxx?name=<script>alert('aaa')</script>`

2、网站给受害者的返回中正常的网页

3、用户的浏览器收到文本后执行页面合法脚本，这时候页面恶意脚本会被执行，会在网页中弹窗aaa

这种攻击方式发生在我们合法的js执行中，服务器无法检测我们的请求是否有攻击的危险

攻击的危害

攻击者把代码注入进了访问的页面，所以恶意脚本都在网站的上下文环境中执行，这就意味着恶意代码被当做网站提供的正常脚本一样对待：他有权访问页面与网站的关键数据（比如cookie）,浏览器会认为他是网站的合法部分，允许他做任何事情。比如拿到用户的cookie信息，然后传送到攻击者自己的服务器，从cookie中提取敏感信息，拿到用户的登录信息，或者攻击者可以通过修改DOM在页面上插入一个假的登陆框，也可以把表单的`action`属性指向他自己的服务器地址，然后欺骗用户提交自己的敏感信息。

如何防止攻击

XSS攻击其实就是代码的注入。用户的输入被编译成恶意的程序代码。所以，为了防范这一类代码的注入，需要确保用户输入的安全性。对于攻击验证，我们可以采用以下两种措施：

1、编码，就是转义用户的输入，把用户的输入解读为数据而不是代码

2、校验，对用户的输入及请求都进行过滤检查，如对特殊字符进行过滤，设置输入域的匹配规则等。

对于验证输入，我们既可以在服务端验证，也可以在客户端验证

对于持久性和反射型攻击，服务端的验证是必须的，服务端支付的任何语言都能够做到

而对于基于DOM的XSS攻击，验证输入在客户端必须执行，因为从服务端来说，所有发出的页面内容是正常的，只是在客户端js代码执行的过程中才发生可攻击

但是对于各种攻击，我们最好做到客户端和服务端都进行处理。这里，我们主要讨论的是客户端的验证，至于服务端如何过滤验证，可以查看其它资料

编码

在客户端使用javascript对用户输入进行编码时，有一些内置的方法和属性能够自动感知对上下文的情况下自动对所有的数据进行编码

下表就是一些自动编码的方式：


 这些内置的方法会对用户的输入自动编码

但是对于用户的自动输入进行编码也会有弊端，恶意文本也有可能插入进上下文中。看下面的例子：

document.querySelector(‘a’).href = “javascript:alert(‘aaa’)”

虽然给href属性的时候会被自动编码，但是这已不能组织攻击者嵌入执行脚本。

另外，如果需求是可以让用户自定义页面的代码，对输入进行编码也不是一个很好的解决方案。编码会把用户的输入当成纯文本输出，这样就跟需求不符了。

针对这样的情况，我们只能对文本进行校验了。

校验

校验是一种过滤用户输入以至于让代码中恶意部分被移除的行为。校验都是通过一定的经验和规则，对用户的输入进行匹配，过滤，去除掉存在攻击风险的部分。我们可以通过黑名单的方式和白名单的方式来设置我们的规则

比如： 我们在检测a 标签的时候，只要输入带入javascript字段的时候，我们就认为非法，javascript字段就成为我们黑名单的匹配规则

同时，我们可以采用另外一种检测方式，只要a标签有href属性的时候，我们只允许http协议的链接，如果是我们通过，不是就认为非法，这里就需要我们建立一张白名单的匹配规则

白名单和黑名单都可以对数据进行过滤，但是黑名单会随着攻击方式的变化而改变，对于规则的使用，白名单更具长效性。所以对于匹配规则最好采用白名单的机制

下面有一个类库是针对防XSS攻击的，可以引入到我们日常项目中使用：

https://github.com/leizongmin/js-xss

Content Security Policy(CSP)

只使用验证输入来防止XSS攻击的劣势在于即使存在一丝的漏洞也会使得你的网站遭到攻击。最近的一个被称为Content Security Policy（CSP）的标准能够减少这个风险。

CSP对你用于浏览页面的浏览器做出了限制，以确保它只能从可信赖来源下载的资源。*资源*可以是脚本，样式，图片，或者其他被页面引用的文件。这意味着即使攻击者成功的在你的网站中注入了恶意内容，CSP也能免于它被执行。

CSP也是采用白名单的方式来匹配网页的解析和代码的执行，只不过，执行的层次上升到了浏览器的高度，对于CSP如何设置，可以参考以下的文章：

https://mp.weixin.qq.com/s/Pz7gS9_7J16wZGrR8zgR8g

总结：

在日常的开发过程中，我们对于用户的输入嵌入到页面中要格外小心，根据嵌入内容的上下文，采取不同的防范策略，提高我们页面的安全性

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

151. #### 作用域

function person() { return this.name; } var someOne = { name: 'Jenny', age: 18 }; // 此处如何输出 'Jenny'
<details><summary><b>答案</b></summary>
person.call(someOne)
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

152. #### 语法题

有一个合法的 JSON 对象（即不包含函数等值的对象），设计一个函数，取出该对象内所有 key 为 "id" 并且其值不为对象、数组的值，装入一个数组并返回。 

```js
function extractIds(data) { 
// implement 
} 
// 样例数据： 
var data = { id: 1, items: [ { id: 2 }, { item: 3, id: [ { id: 4 }, { id: 5 } ]} ] }; 
extractIds(data); // should return [ 1, 2, 4, 5 ]
```
<details><summary><b>答案</b></summary>
<pre>
解题

function getId(data){ 
 let stack = [ data ] ,ret = [];
 while(stack.length > 0){
  let cur = stack.pop();
  for(let key in cur){
      if(cur[key] instanceof Object ){
        stack.push(cur[key]);
      }else{
       if(key === "id") ret.push(cur[key]);
      }
  }
return ret ;
}
</pre>
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

153. #### 闭包

下面五段代码分别输出什么？并且什么时候输出什么？
```js
for (var i = 0; i < 5; i++) {
    console.log(i);
  }
  for (var i = 0; i < 5; i++) {
    setTimeout(function () {
      console.log(i);
    }, 1000 * i);
  }
  for (var i = 0; i < 5; i++) {
    (function (i) {
      setTimeout(function () {
        console.log(i);
      }, i * 1000);
    })(i);
  }
  for (var i = 0; i < 5; i++) {
    (function () {
      setTimeout(function () {
        console.log(i);
      }, i * 1000);
    })(i);
  }
  for (var i = 0; i < 5; i++) {
    setTimeout((function (i) {
      console.log(i);
    })(i), i * 1000);
  }
  // _.pluck(list, propertyName)
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };
```
<details><summary><b>答案</b></summary>
答案
1. 立即输出0-4

2. 0-4秒间输出 5

3. 0-4秒间输出 0-4

4. 0-4秒间输出 5

5. 立即输出 0-4
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

153. #### <a id="promise和callback的区别"></a> promise和callback的区别(海康)

<details><summary><b>答案</b></summary>
首先，js中的callback与promise的区别实际就是宽度和深度的区别。

1.回调函数：函数当参数，传递另外一个函数

定义：在JavaScript中，回调函数具体的定义为：函数A作为参数(函数引用)传递到另一个函数B中，  并且这个函数B执行函数A。我们就说函数A叫做回调函数。如果没有名称(函数表达式)，就  叫做匿名回调函数。

回调函数应用场景实例：

1.缓冲运动回调函数---链式。

2.ajax函数封装--完成某个动作，取返回值。

3.jsonp里面--函数名当作参数。

弊端：回调函数的嵌套：可读性很差 。

2.promise：异步编程的一种解决方案（es6）。可取代callback

     promise构造函数：比传统的回调函数更合理，更强大。

     创建promise实例对象,构造函数的参数又是一个函数对象，函数对象里面又有两个参数，一个 代表成功的回调，一个是失败的回调。

      promise状态：pending(进行中) resolve(成功，已解决) reject(失败，未解决)  ， 状态一旦设定，不可改变。

      pending-->resolve 进行中-->成功

      pending-->reject 进行中-->失败
————————————————
版权声明：本文为CSDN博主「zhanghe-V」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41849462/article/details/81988637

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

154. #### axios封装用什么处理异常其原理其返回的是什么海康

<details><summary><b>答案</b></summary>
axios用Promise封装请求拦截 处理异常问题 原理没答上来 返回的是一个Promise
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

155. #### 正则题

var string = "我的账户余额：2,235,467.20"; console.log(?); // 请用js计算出我到底有多少钱（输出Number类型数字，代码尽量简洁，考虑通用情况）
<details><summary><b>答案</b></summary>

parseFloat(string.match(/\d+|\./g).join(""))
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

156. #### 闭包海康

<details><summary><b>答案</b></summary>
闭包是函数和声明该函数的词法环境的组合。
1. 用闭包模拟私有方法
2. 在循环中创建闭包：一个常见错误
3. 性能考量

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

function A() {
  let a = 1
  window.B = function () {
      console.log(a)
  }
}
A()
B() // 1

循环中使用闭包解决 `var` 定义函数的问题

for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。

解决办法有三种，第一种是使用闭包的方式

for (var i = 1; i <= 5; i++) {
  ;(function(j) {
    setTimeout(function timer() {
      console.log(j)
    }, j * 1000)
  })(i)
}
在上述代码中，我们首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。

第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。

for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j)
    },
    i * 1000,
    i
  )
}
第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式

for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

157. #### 原始类型有哪几种null是对象嘛

##### 题目：原始类型有哪几种？null 是对象嘛？
<details><summary><b>答案</b></summary>
在 JS 中，存在着 6 种原始值，分别是：

boolean
null
undefined
number
string
symbol
首先原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()

![avatar](https://user-gold-cdn.xitu.io/2018/11/14/16711c4f991c73ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

此时你肯定会有疑问，这不对呀，明明 '1'.toString() 是可以使用的。其实在这种情况下，'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。

除了会在必要的情况下强转类型以外，原始类型还有一些坑。

其中 JS 的 number 类型是浮点类型的，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3，但是这一块的内容会在进阶部分讲到。string 类型是不可变的，无论你在 string 类型上调用何种方法，都不会对值有改变。

另外对于 null 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

158. #### 对象类型和原始类型的不同之处函数参数是对象会发生什么问题

对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？
<details><summary><b>答案</b></summary>
在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

const a = []
对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001，再看以下代码

const a = []
const b = a
b.push(1)
当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 b 存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变。

接下来我们来看函数参数是对象的情况

function test(person) {
  person.age = 26
  person = {
    name: 'yyy',
    age: 30
  }

  return person
}
const p1 = {
  name: 'yck',
  age: 25
}
const p2 = test(p1)
console.log(p1) // -> ?
console.log(p2) // -> ?
对于以上代码，你是否能正确的写出结果呢？接下来让我为你解析一番：

首先，函数传参是传递对象指针的副本
到函数内部修改参数的属性这步，我相信大家都知道，当前 p1 的值也被修改了
但是当我们重新为 person 分配了一个对象时就出现了分歧，请看下图

![avatar](https://user-gold-cdn.xitu.io/2018/11/14/16712ce155afef8c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

所以最后 person 拥有了一个新的地址（指针），也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

159. #### typeof是否能正确判断类型instanceof能正确判断对象的原理是什么

typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？
<details><summary><b>答案</b></summary>
typeof 对于原始类型来说，除了 null 都可以显示正确的类型

typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型

typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的，在后面的章节中我们也会自己去实现一个 instanceof。

const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true
对于原始类型来说，你想直接通过 instanceof 来判断类型是不行的，当然我们还是有办法让 instanceof 判断原始类型的

class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
你可能不知道 Symbol.hasInstance 是什么东西，其实就是一个能让我们自定义 instanceof 行为的东西，以上代码等同于 typeof 'hello world' === 'string'，所以结果自然是 true 了。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

160. #### ==和===有什么区别

== 和 === 有什么区别？
<details><summary><b>答案</b></summary>
对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换

假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程：

首先会判断两者类型是否相同。相同的话就是比大小了
类型不相同的话，那么就会进行类型转换
会先判断是否在对比 null 和 undefined，是的话就会返回 true
判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number
1 == '1'
      ↓
1 ==  1
判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断
'1' == true
        ↓
'1' ==  1
        ↓
 1  ==  1
判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断
'1' == { name: 'yck' }
        ↓
'1' == '[object Object]'



[ ] == ![ ] 的判断本质上是原始类型和引用类型的判断，一元运算符 ! 优先级高于二元运算符 ==，实际 == 判断时表达式已经转为 [ ] == false，然后 == 导致的隐式转换，二者都转为数值 0 == 0 就返回 true 了。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

161. #### 如何正确判断this箭头函数的this是什么

##### 题目： 如何正确判断 this？箭头函数的 this 是什么？

<details><summary><b>答案</b></summary>
this 是很多人会混淆的概念，但是其实它一点都不难，只是网上很多文章把简单的东西说复杂了。在这一小节中，你一定会彻底明白 this 这个概念的。

我们先来看几个函数调用的场景

function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
接下来我们一个个分析上面几个场景

对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window
对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象
对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this
说完了以上几种情况，其实很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this

function a() {
  return () => {
    return () => {
      console.log(this)
    }
  }
}
console.log(a()()())
首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。

最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。

那么说到 bind，不知道大家是否考虑过，如果对一个函数进行多次 bind，那么上下文会是什么呢？

let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // => ?
如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式

// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2()
可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。

let a = { name: 'yck' }
function foo() {
  console.log(this.name)
}
foo.bind(a)() // => 'yck'
以上就是 this 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。

首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。

如果你还是觉得有点绕，那么就看以下的这张流程图吧，图中的流程只针对于单个规则。

![avatar](https://user-gold-cdn.xitu.io/2018/11/15/16717eaf3383aae8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

162. #### 如何理解原型如何理解原型链

如何理解原型？如何理解原型链？
<details><summary><b>答案</b></summary>
本文不会过多介绍基础知识，而是把重点放在原型的各个难点上。



大家可以先仔细分析下该图，然后让我们进入主题

prototype
首先来介绍下 prototype 属性。这是一个显式原型属性，只有函数才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外

let fun = Function.prototype.bind()
如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 prototype 属性的。

prototype 如何产生的
当我们声明一个函数时，这个属性就被自动创建了。

function Foo() {}
并且这个属性的值是一个对象（也就是原型），只有一个属性 constructor



constructor 对应着构造函数，也就是 Foo。

constructor
constructor 是一个公有且不可枚举的属性。一旦我们改变了函数的 prototype ，那么新对象就没有这个属性了（当然可以通过原型链取到 constructor）。



那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：

让实例对象知道是什么函数构造了它
如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展
_proto_
这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 _proto_ 来访问。

因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 _proto_ 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。

实例对象的 _proto_ 如何产生的
从上图可知，当我们使用 new 操作符时，生成的实例对象拥有了 _proto_属性。

function Foo() {}
// 这个函数是 Function 的实例对象
// function 就是一个语法糖
// 内部调用了 new Function(...)
所以可以说，在 new 的过程中，新对象被添加了 _proto_ 并且链接到构造函数的原型上。

new 的过程
新生成了一个对象
链接到原型
绑定 this
返回新对象
在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new

function create() {
	// 创建一个空的对象
	let obj = new Object()
	// 获得构造函数
	let Con = [].shift.call(arguments)
	// 链接到原型
	obj.__proto__ = Con.prototype
	// 绑定 this，执行构造函数
	let result = Con.apply(obj, arguments)
	// 确保 new 出来的是个对象
	return typeof result === 'object' ? result : obj
}
对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。

对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。

function Foo() {}
// function 就是个语法糖
// 内部等同于 new Function()
let a = { b: 1 }
// 这个字面量内部也是使用了 new Object()
Function.proto === Function.prototype
对于对象来说，xx.__proto__.contrcutor 是该对象的构造函数，但是在图中我们可以发现 Function.__proto__ === Function.prototype，难道这代表着 Function 自己产生了自己?

答案肯定是否认的，要说明这个问题我们先从 Object 说起。

从图中我们可以发现，所有对象都可以通过原型链最终找到 Object.prototype ，虽然 Object.prototype 也是一个对象，但是这个对象却不是 Object 创造的，而是引擎自己创建了 Object.prototype 。所以可以这样说，所有实例都是对象，但是对象不一定都是实例。

接下来我们来看 Function.prototype 这个特殊的对象，如果你在浏览器将这个对象打印出来，会发现这个对象其实是一个函数。



我们知道函数都是通过 new Function() 生成的，难道 Function.prototype 也是通过 new Function() 产生的吗？答案也是否定的，这个函数也是引擎自己创建的。首先引擎创建了 Object.prototype ，然后创建了 Function.prototype ，并且通过 __proto__ 将两者联系了起来。这里也很好的解释了上面的一个问题，为什么 let fun = Function.prototype.bind() 没有 prototype 属性。因为 Function.prototype 是引擎创建出来的对象，引擎认为不需要给这个对象添加 prototype 属性。

所以我们又可以得出一个结论，不是所有函数都是 new Function() 产生的。

有了 Function.prototype 以后才有了 function Function() ，然后其他的构造函数都是 function Function() 生成的。

现在可以来解释 Function.__proto__ === Function.prototype 这个问题了。因为先有的 Function.prototype 以后才有的 function Function() ，所以也就不存在鸡生蛋蛋生鸡的悖论问题了。对于为什么 Function.__proto__ 会等于 Function.prototype ，个人的理解是：其他所有的构造函数都可以通过原型链找到 Function.prototype ，并且 function Function() 本质也是一个函数，为了不产生混乱就将 function Function() 的 __proto__ 联系到了 Function.prototype 上。

总结
Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它
Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它
Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建
除了以上两个特殊对象，其他对象都是通过构造器 new 出来的
函数的 prototype 是一个对象，也就是原型
对象的 __proto__ 指向原型， __proto__ 将对象和原型连接起来组成了原型链
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

163. #### 什么是提升什么是暂时性死区varlet及const区别

##### 题目：什么是提升？什么是暂时性死区？var、let 及 const 区别？
<details><summary><b>答案</b></summary>
对于这个问题，我们应该先来了解提升（hoisting）这个概念。

console.log(a) // undefined
var a = 1
从上述代码中我们可以发现，虽然变量还没有被声明，但是我们却可以使用这个未被声明的变量，这种情况就叫做提升，并且提升的是声明。

对于这种情况，我们可以把代码这样来看

var a
console.log(a) // undefined
a = 1
接下来我们再来看一个例子

var a = 10
var a
console.log(a)
对于这个例子，如果你认为打印的值为 undefined 那么就错了，答案应该是 10，对于这种情况，我们这样来看代码

var a
var a
a = 10
console.log(a)
到这里为止，我们已经了解了 var 声明的变量会发生提升的情况，其实不仅变量会提升函数也会被提升。

console.log(a) // ƒ a() {}
function a() {}
var a = 1
对于上述代码，打印结果会是 ƒ a() {}，即使变量声明在函数之后，这也说明了函数会被提升，并且优先于变量提升。

说完了这些，想必大家也知道 var 存在的问题了，使用 var 声明的变量会被提升到作用域的顶部，接下来我们再来看 let 和 const 。

我们先来看一个例子：

var a = 1
let b = 1
const c = 1
console.log(window.b) // undefined
console.log(window. c) // undefined

function test(){
  console.log(a)
  let a
}
test()
首先在全局作用域下使用 let 和 const 声明变量，变量并不会被挂载到 window 上，这一点就和 var 声明有了区别。

再者当我们在声明 a 之前如果使用了 a，就会出现报错的情况


你可能会认为这里也出现了提升的情况，但是因为某些原因导致不能访问。

首先报错的原因是因为存在暂时性死区，我们不能在声明前就使用变量，这也是 let 和 const 优于 var 的一点。然后这里你认为的提升和 var 的提升是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。

那么到这里，想必大家也都明白 var、let 及 const 区别了，不知道你是否会有这么一个疑问，为什么要存在提升这个事情呢，其实提升存在的根本原因就是为了解决函数间互相调用的情况

function test1() {
    test2()
}
function test2() {
    test1()
}
test1()
假如不存在提升这个情况，那么就实现不了上述的代码，因为不可能存在 test1 在 test2 前面然后 test2 又在 test1 前面。

那么最后我们总结下这小节的内容：

函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部
var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用
var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会
let 和 const 作用基本一致，但是后者声明的变量不能再次赋值
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

164. #### 原型如何实现继承Class如何实现继承Class本质是什么

##### 题目：原型如何实现继承？Class 如何实现继承？Class 本质是什么？
<details><summary><b>答案</b></summary>
首先先来讲下 class，其实在 JS 中并不存在类，class 只是语法糖，本质还是函数。

class Person {}
Person instanceof Function // true
在上一章节中我们讲解了原型的知识点，在这一小节中我们将会分别使用原型和 class 的方式来实现继承。

组合继承
组合继承是最常用的继承方式，

function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
以上继承的方式核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。

这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。


寄生组合继承
这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。

function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}

function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。


Class 继承
以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单

class Parent {
  constructor(value) {
    this.val = value
  }
  getValue() {
    console.log(this.val)
  }
}
class Child extends Parent {
  constructor(value) {
    super(value)
  }
}
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。

当然了，之前也说了在 JS 中并不存在类，class 的本质就是函数。

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

165. #### 为什么要使用模块化都有哪几种方式可以实现模块化各有什么特点

##### 题目：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？
<details><summary><b>答案</b></summary>
使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处

解决命名冲突
提供复用性
提高代码可维护性
立即执行函数
在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题

(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
AMD 和 CMD
鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。

// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
CommonJS
CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

// a.js
module.exports = {
    a: 1
}
// or 
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析

先说 require 吧

var module = require('./a.js')
module.a 
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = {
    a: 1
}
// module 基本实现
var module = {
  id: 'xxxx', // 我总得知道怎么去找到他吧
  exports: {} // exports 就是个空对象
}
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports 
var load = function (module) {
    // 导出的东西
    var a = 1
    module.exports = a
    return module.exports
};
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
另外虽然 exports 和 module.exports 用法相似，但是不能对 exports 直接赋值。因为 var exports = module.exports 这句代码表明了 exports 和 module.exports 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 exports 赋值就会导致两者不再指向同一个内存地址，修改并不会对 module.exports 起效。

ES Module
ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别

CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案
CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
ES Module 会编译成 require/exports 来执行的
// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

166. #### Proxy可以实现什么功能

##### 题目：Proxy 可以实现什么功能？

<details><summary><b>答案</b></summary>
如果你平时有关注 Vue 的进展的话，可能已经知道了在 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。 Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。

let p = new Proxy(target, handler)
target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。

接下来我们通过 Proxy 来实现一个数据响应式

let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver)
    },
    set(target, property, value, receiver) {
      setBind(value, property)
      return Reflect.set(target, property, value)
    }
  }
  return new Proxy(obj, handler)
}

let obj = { a: 1 }
let p = onWatch(
  obj,
  (v, property) => {
    console.log(`监听到属性${property}改变为${v}`)
  },
  (target, property) => {
    console.log(`'${property}' = ${target[property]}`)
  }
)
p.a = 2 // 监听到属性a改变
p.a // 'a' = 2
在上述代码中，我们通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。

当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。

更新：评论中有同学对于 Proxy 无需一层层递归为每个属性添加代理有疑问，以下是实现代码。

get(target, property, receiver) {
    getLogger(target, property)
    // 这句判断代码是新增的
    if (typeof target[property] === 'object' && target[property] !== null) {
        return new Proxy(target[property], handler);
    } else {
        return Reflect.get(target, property);
    }
}
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

167. #### mapfilterreduce各自有什么作用

##### 题目：map, filter, reduce 各自有什么作用？
<details><summary><b>答案</b></summary>
map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。

[1, 2, 3].map(v => v + 1) // -> [2, 3, 4]
另外 map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组

['1','2','3'].map(parseInt)
第一轮遍历 parseInt('1', 0) -> 1
第二轮遍历 parseInt('2', 1) -> NaN
第三轮遍历 parseInt('3', 2) -> NaN
filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素

let array = [1, 2, 4, 6]
let newArray = array.filter(item => item !== 6)
console.log(newArray) // [1, 2, 4]
和 map 一样，filter 的回调函数也接受三个参数，用处也相同。

最后我们来讲解 reduce 这块的内容，同时也是最难理解的一块内容。reduce 可以将数组中的元素通过回调函数最终转换为一个值。

如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码

const arr = [1, 2, 3]
let total = 0
for (let i = 0; i < arr.length; i++) {
  total += arr[i]
}
console.log(total) //6 
但是如果我们使用 reduce 的话就可以将遍历部分的代码优化为一行代码

const arr = [1, 2, 3]
const sum = arr.reduce((acc, current) => acc + current, 0)
console.log(sum)
对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 reduce 的过程

首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入
回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数
在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入
所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6
想必通过以上的解析大家应该明白 reduce 是如何通过回调函数将所有元素最终转换为一个值的，当然 reduce 还可以实现很多功能，接下来我们就通过 reduce 来实现 map 函数

const arr = [1, 2, 3]
const mapArray = arr.map(value => value * 2)
const reduceArray = arr.reduce((acc, current) => {
  acc.push(current * 2)
  return acc
}, [])
console.log(mapArray, reduceArray) // [2, 4, 6]
如果你对这个实现还有困惑的话，可以根据上一步的解析步骤来分析过程。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

168. #### 并发与并行的区别

<details><summary><b>答案</b></summary>
异步和这小节的知识点其实并不是一个概念，但是这两个名词确实是很多人都常会混淆的知识点。其实混淆的原因可能只是两个名词在中文上的相似，在英文上来说完全是不同的单词。

并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。

并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

169. #### 什么是回调函数回调函数有什么缺点如何解决回调地狱问题

##### 题目：什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？
<details><summary><b>答案</b></summary>
回调函数应该是大家经常使用到的，以下代码就是一个回调函数的例子：

ajax(url, () => {
    // 处理逻辑
})
但是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：

ajax(url, () => {
    // 处理逻辑
    ajax(url1, () => {
        // 处理逻辑
        ajax(url2, () => {
            // 处理逻辑
        })
    })
})
以上代码看起来不利于阅读和维护，当然，你可能会想说解决这个问题还不简单，把函数分开来写不就得了

function firstAjax() {
  ajax(url1, () => {
    // 处理逻辑
    secondAjax()
  })
}
function secondAjax() {
  ajax(url2, () => {
    // 处理逻辑
  })
}
ajax(url, () => {
  // 处理逻辑
  firstAjax()
})
以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。

回调地狱的根本问题就是：

嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
嵌套函数一多，就很难处理错误
当然，回调函数还存在着别的几个缺点，比如不能使用 try catch 捕获错误，不能直接 return。在接下来的几小节中，我们将来学习通过别的技术解决这些问题。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

170. #### 你理解的Generator是什么

<details><summary><b>答案</b></summary>
Generator 算是 ES6 中难理解的概念之一了，Generator 最大的特点就是可以控制函数的执行。在这一小节中我们不会去讲什么是 Generator，而是把重点放在 Generator 的一些容易困惑的地方。

function *foo(x) {
  let y = 2 * (yield (x + 1))
  let z = yield (y / 3)
  return (x + y + z)
}
let it = foo(5)
console.log(it.next())   // => {value: 6, done: false}
console.log(it.next(12)) // => {value: 8, done: false}
console.log(it.next(13)) // => {value: 42, done: true}

你也许会疑惑为什么会产生与你预想不同的值，接下来就让我为你逐行代码分析原因

首先 Generator 函数调用和普通函数不同，它会返回一个迭代器
当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6
当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8
当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42
Generator 函数一般见到的不多，其实也于他有点绕有关系，并且一般会配合 co 库去使用。当然，我们可以通过 Generator 函数解决回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：

function *fetch() {
    yield ajax(url, () => {})
    yield ajax(url1, () => {})
    yield ajax(url2, () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

172. #### async及await的特点它们的优点和缺点分别是什么await原理是什么

 async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？
<details><summary><b>答案</b></summary>
一个函数如果加上 async ，那么该函数就会返回一个 Promise

async function test() {
  return "1"
}
console.log(test()) // -> Promise {<resolved>: "1"}
async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样，并且 await 只能配套 async 使用

async function test() {
  let value = await sleep()
}
async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。

async function test() {
  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch(url)
  await fetch(url1)
  await fetch(url2)
}
下面来看一个使用 await 的例子：

let a = 0
let b = async () => {
  a = a + await 10
  console.log('2', a) // -> '2' 10
}
b()
a++
console.log('1', a) // -> '1' 1
对于以上代码你可能会有疑惑，让我来解释下原因

首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来
因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码
同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10
上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

173. #### setTimeoutsetIntervalrequestAnimationFrame各有什么特点

##### 题目：setTimeout、setInterval、requestAnimationFrame 各有什么特点？

<details><summary><b>答案</b></summary>
异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。我们先来讲讲最常用的setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行。

其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，我们可以通过代码去修正 setTimeout，从而使定时器相对准确

let period = 60 * 1000 * 60 * 2
let startTime = new Date().getTime()
let count = 0
let end = new Date().getTime() + period
let interval = 1000
let currentInterval = interval

function loop() {
  count++
  // 代码执行所消耗的时间
  let offset = new Date().getTime() - (startTime + count * interval);
  let diff = end - new Date().getTime()
  let h = Math.floor(diff / (60 * 1000 * 60))
  let hdiff = diff % (60 * 1000 * 60)
  let m = Math.floor(hdiff / (60 * 1000))
  let mdiff = hdiff % (60 * 1000)
  let s = mdiff / (1000)
  let sCeil = Math.ceil(s)
  let sFloor = Math.floor(s)
  // 得到下一次循环所消耗的时间
  currentInterval = interval - offset 
  console.log('时：'+h, '分：'+m, '毫秒：'+s, '秒向上取整：'+sCeil, '代码执行时间：'+offset, '下次循环间隔'+currentInterval) 

  setTimeout(loop, currentInterval)
}

setTimeout(loop, currentInterval)
接下来我们来看 setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。

通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码

function demo() {
  setInterval(function(){
    console.log(2)
  },1000)
  sleep(2000)
}
demo()
以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。

如果你有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现

function setInterval(callback, interval) {
  let timer
  const now = Date.now
  let startTime = now()
  let endTime = startTime
  const loop = () => {
    timer = window.requestAnimationFrame(loop)
    endTime = now()
    if (endTime - startTime >= interval) {
      startTime = endTime = now()
      callback(timer)
    }
  }
  timer = window.requestAnimationFrame(loop)
  return timer
}

let a = 0
setInterval(timer => {
  console.log(1)
  a++
  if (a === 3) cancelAnimationFrame(timer)
}, 1000)
首先 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

174. #### 手写Promise

<details><summary><b>答案</b></summary>
实现一个简易版 Promise
在完成符合 Promise/A+ 规范的代码之前，我们可以先来实现一个简易版 Promise，因为在面试中，如果你能实现出一个简易版的 Promise 基本可以过关了。

那么我们先来搭建构建函数的大体框架

const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

function MyPromise(fn) {
  const that = this
  that.state = PENDING
  that.value = null
  that.resolvedCallbacks = []
  that.rejectedCallbacks = []
  // 待完善 resolve 和 reject 函数
  // 待完善执行 fn 函数
}
首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护
在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象
一开始 Promise 的状态应该是 pending
value 变量用于保存 resolve 或者 reject 中传入的值
resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用
接下来我们来完善 resolve 和 reject 函数，添加在 MyPromise 函数体内部

function resolve(value) {
  if (that.state === PENDING) {
    that.state = RESOLVED
    that.value = value
    that.resolvedCallbacks.map(cb => cb(that.value))
  }
}

function reject(value) {
  if (that.state === PENDING) {
    that.state = REJECTED
    that.value = value
    that.rejectedCallbacks.map(cb => cb(that.value))
  }
}
这两个函数代码类似，就一起解析了

首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态
将当前状态更改为对应状态，并且将传入的值赋值给 value
遍历回调数组并执行
完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了

try {
  fn(resolve, reject)
} catch (e) {
  reject(e)
}
实现很简单，执行传入的参数并且将之前两个函数当做参数传进去
要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数
最后我们来实现较为复杂的 then 函数

MyPromise.prototype.then = function(onFulfilled, onRejected) {
  const that = this
  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
  onRejected =
    typeof onRejected === 'function'
      ? onRejected
      : r => {
          throw r
        }
  if (that.state === PENDING) {
    that.resolvedCallbacks.push(onFulfilled)
    that.rejectedCallbacks.push(onRejected)
  }
  if (that.state === RESOLVED) {
    onFulfilled(that.value)
  }
  if (that.state === REJECTED) {
    onRejected(that.value)
  }
}
首先判断两个参数是否为函数类型，因为这两个参数是可选参数

当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码

// 该代码目前在简单版中会报错
// 只是作为一个透传的例子
Promise.resolve(4).then().then((value) => console.log(value))
接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数，比如如下代码就会进入等待态的逻辑

new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve(1)
  }, 0)
}).then(value => {
  console.log(value)
})
以上就是简单版 Promise 实现，接下来一小节是实现完整版 Promise 的解析，相信看完完整版的你，一定会对于 Promise 的理解更上一层楼。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

175. #### 异步代码执行顺序解释一下什么是EventLoop坚果云

##### 题目：异步代码执行顺序？解释一下什么是 Event Loop ？(坚果云)
<details><summary><b>答案</b></summary>

Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。

为啥要弄懂Event Loop
是要增加自己技术的深度，也就是懂得JavaScript的运行机制。

现在在前端领域各种技术层出不穷，掌握底层原理，可以让自己以不变，应万变。

在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。


MacroTask（宏任务）
script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。


MicroTask（微任务）
Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver

浏览器中的Event Loop
Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。

JS调用栈
JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。

同步任务和异步任务
Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。


事件循环的进程模型

选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。
将事件循环中的任务设置为已选择任务。
执行任务。
将事件循环中当前运行任务设置为null。
将已经运行完成的任务从任务队列中删除。
microtasks步骤：进入microtask检查点。
更新界面渲染。
返回第一步。

执行进入microtask检查点时，用户代理会执行以下步骤：

设置microtask检查点标志为true。
当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。
清理IndexDB事务
设置进入microtask检查点的标志为false。

执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。
每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。
Node的Event loop一共分为6个阶段，每个细节具体如下：

timers: 执行setTimeout和setInterval中到期的callback。
pending callback: 上一轮循环中少数的callback会放在这一阶段执行。
idle, prepare: 仅在内部使用。
poll: 最重要的阶段，执行pending callback，在适当的情况下回阻塞在这个阶段。
check: 执行setImmediate(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数)的callback。
close callbacks: 执行close事件的callback，例如socket.on('close'[,fn])或者http.server.on('close, fn)。

作者：光光同学
链接：https://juejin.im/post/5c3d8956e51d4511dc72c200
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

上一小节我们讲到了什么是执行栈，大家也知道了当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。


事件循环
不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。下面来看以下代码的执行顺序：

console.log('script start')

async function async1() {
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2 end')
}
async1()

setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(resolve => {
  console.log('Promise')
  resolve()
})
  .then(function() {
    console.log('promise1')
  })
  .then(function() {
    console.log('promise2')
  })

console.log('script end')
// script start => async2 end => Promise => script end => promise1 => promise2 => async1 end => setTimeout
注意：新的浏览器中不是如上打印的，因为 await 变快了，具体内容可以往下看

首先先来解释下上述代码的 async 和 await 的执行顺序。当我们调用 async1 函数时，会马上输出 async2 end，并且函数返回一个 Promise，接下来在遇到 await的时候会就让出线程开始执行 async1 外的代码，所以我们完全可以把 await 看成是让出线程的标志。

然后当同步代码全部执行完毕以后，就会去执行所有的异步代码，那么又会回到 await 的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，接下来去执行 then 中的回调，当两个 then 中的回调全部执行完毕以后，又会回到 await 的位置处理返回值，这时候你可以看成是 Promise.resolve(返回值).then()，然后 await 后的代码全部被包裹进了 then 的回调中，所以 console.log('async1 end') 会优先执行于 setTimeout。

如果你觉得上面这段解释还是有点绕，那么我把 async 的这两个函数改造成你一定能理解的代码

new Promise((resolve, reject) => {
  console.log('async2 end')
  // Promise.resolve() 将代码插入微任务队列尾部
  // resolve 再次插入微任务队列尾部
  resolve(Promise.resolve())
}).then(() => {
  console.log('async1 end')
})
也就是说，如果 await 后面跟着 Promise 的话，async1 end 需要等待三个 tick 才能执行到。那么其实这个性能相对来说还是略慢的，所以 V8 团队借鉴了 Node 8 中的一个 Bug，在引擎底层将三次 tick 减少到了二次 tick。但是这种做法其实是违法了规范的，当然规范也是可以更改的，这是 V8 团队的一个 PR，目前已被同意这种做法。

所以 Event Loop 执行顺序如下所示：

首先执行同步代码，这属于宏任务
当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
执行所有微任务
当执行完所有微任务后，如有必要会渲染页面
然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数
所以以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。

微任务包括 process.nextTick ，promise ，MutationObserver，其中 process.nextTick 为 Node 独有。

宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。

这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。


</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

176. #### 进程与线程区别JS单线程带来的好处

##### 题目：进程与线程区别？JS 单线程带来的好处？
<details><summary><b>答案</b></summary>
相信大家经常会听到 JS 是单线程执行的，但是你是否疑惑过什么是线程？

讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 CPU 工作时间片的一个描述。

进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。

把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

上文说到了 JS 引擎线程和渲染线程，大家应该都知道，在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。
</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

177. #### 什么是执行栈

<details><summary><b>答案</b></summary>
可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。


执行栈可视化
当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo 函数后执行，当执行完毕后就从栈中弹出了。

平时在开发中，大家也可以在报错中找到执行栈的痕迹

function foo() {
  throw new Error('error')
}
function bar() {
  foo()
}
bar()
![avatar](https://user-gold-cdn.xitu.io/2018/11/13/1670c0e21540090c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
函数执行顺序
大家可以在上图清晰的看到报错在 foo 函数，foo 函数又是在 bar 函数中调用的。

当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题

function bar() {
  bar()
}
bar()

爆栈
![avatar](https://user-gold-cdn.xitu.io/2018/11/13/1670c128acce975f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

178. #### Node中的EventLoop和浏览器中的有什么区别processnexttick执行顺序

 Node 中的 Event Loop 和浏览器中的有什么区别？process.nexttick 执行顺序？
<details><summary><b>答案</b></summary>
Node 中的 Event Loop 和浏览器中的是完全不相同的东西。

Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。
timer
timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。

同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。

I/O
I/O 阶段会处理一些上一轮循环中的少数未执行的 I/O 回调

idle, prepare
idle, prepare 阶段内部实现，这里就忽略不讲了。

poll
poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情

回到 timer 阶段执行回调
执行 I/O 回调
并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情

如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
如果 poll 队列为空时，会有两件事发生
如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去
当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。

check
check 阶段执行 setImmediate

close callbacks
close callbacks 阶段执行 close 事件

在以上的内容中，我们了解了 Node 中的 Event Loop 的执行顺序，接下来我们将会通过代码的方式来深入理解这块内容。

首先在有些情况下，定时器的执行顺序其实是随机的

setTimeout(() => {
    console.log('setTimeout')
}, 0)
setImmediate(() => {
    console.log('setImmediate')
})
对于以上代码来说，setTimeout 可能执行在前，也可能执行在后

首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的
进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调
那么如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了
当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：

const fs = require('fs')

fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})
在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。

上面介绍的都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask
setTimeout(() => {
  console.log('timer21')
}, 0)

Promise.resolve().then(function() {
  console.log('promise1')
})
对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。

最后我们来讲讲 Node 中的 process.nextTick，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。

setTimeout(() => {
 console.log('timer1')

 Promise.resolve().then(function() {
   console.log('promise1')
 })
}, 0)

process.nextTick(() => {
 console.log('nextTick')
 process.nextTick(() => {
   console.log('nextTick')
   process.nextTick(() => {
     console.log('nextTick')
     process.nextTick(() => {
       console.log('nextTick')
     })
   })
 })
})
对于以上代码，大家可以发现无论如何，永远都是先把 nextTick 全部打印出来。
https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-11

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

179. #### 使用正则表达式验证邮箱格式

##### 题目：使用正则表达式验证邮箱格式(大搜车)
<details><summary><b>答案</b></summary>

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

180. #### 判断数组

##### 题目：判断数组(大搜车)
<details><summary><b>答案</b></summary>

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

181. #### 实现indexof

实现indexof(大搜车)
<details><summary><b>答案</b></summary>

</details>

---

[[↑] 回到顶部](#awsome-knowledge-front-end)


182. #### promiseall如果三个请求中第一个发生错误是会继续执行吗

##### 题目：promise.all 如果三个请求中第一个发生错误是会继续执行吗（海康）

Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。

Promise.all 在任意一个传入的 promise 失败时返回失败。例如，如果你传入的 promise中，有四个 promise 在一定的时间之后调用成功函数，有一个立即调用失败函数，那么 Promise.all 将立即变为失败。

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

183. #### 取消promise

取消promise（海康）

概述
在项目开发中离不了的需要进行一些异步操作，这些异步操作在改善用户体验的同时也带来了一些性能隐患。 比如，在某页面进行异步操作，异步操作还没有完成时，该页面已经关闭，这时由于异步操作的存在，导致系统无法及时的回收资源，从而导致性能的降低，甚至出现oom。

总而言之，异步操作在改善用户体验，增强系统灵活性的同时也带来了一些性能隐患，如果使用不当则会带来一些副作用。

那么如何在使用异步操作的同时规避它所带来的副作用呢？

问题不是出在异步操作上，异步操作本没有错，错在异步操作的不合理使用上。比如，页面已经关闭了，而页面的异步操作还在进行等使用问题。 所以我们需要在编程中学会“舍得”，在适当的时候去取消一些异步操作。

为Promise插上可取消的翅膀
Promise是React Native开发过程中用于异步操作的最常用的API，但Promise没有提供用于取消异步操作的方法。为了实现可取消的异步操作，我们可以为Promise包裹一层可取消的外衣。

const makeCancelable = (promise) => {
  let hasCanceled_ = false;
  const wrappedPromise = new Promise((resolve, reject) => {
    promise.then((val) =>
      hasCanceled_ ? reject({isCanceled: true}) : resolve(val)
    );
    promise.catch((error) =>
      hasCanceled_ ? reject({isCanceled: true}) : reject(error)
    );
  });
  return {
    promise: wrappedPromise,
    cancel() {
      hasCanceled_ = true;
    },
  };
};  
然后可以这样使用取消操作：

const somePromise = new Promise(r => setTimeout(r, 1000));//创建一个异步操作
const cancelable = makeCancelable(somePromise);//为异步操作添加可取消的功能
cancelable
  .promise
  .then(() => console.log('resolved'))
  .catch(({isCanceled, ...error}) => console.log('isCanceled', isCanceled));
// 取消异步操作
cancelable.cancel();   
上述方法，可以为异步操作添加可取消的功能，但是使用还是不够方便：在每个使用makeCancelable的页面都需要复制粘贴上述代码。
下面我们做一下改进，将上述代码抽离到一个文件中。

/**
* Cancelable
* GitHub:https://github.com/crazycodeboy
* Eamil:crazycodeboy@gmail.com 
* @flow
**/
'use strict'

export default function makeCancelable(promise){
   let hasCanceled_ = false;
   const wrappedPromise = new Promise((resolve, reject) => {
       promise.then((val) =>
           hasCanceled_ ? reject({isCanceled: true}) : resolve(val)
       );
       promise.catch((error) =>
           hasCanceled_ ? reject({isCanceled: true}) : reject(error)
       );
   });

   return {
       promise: wrappedPromise,
       cancel() {
           hasCanceled_ = true;
       },
   };
}
这样在使用的时候只需要将makeCancelable导入到你的相应js文件中就可以了。

import makeCancelable from '../util/Cancelable'
可取消的网络请求fetch
fetch是React Native开发过程中最常用的网络请求API，和Promis一样，fetch也没有提供用于取消已发出的网络请求的API。因为fetch返回的是一个Promise，所以我们可以借助上述方法，�来取消fetch所发出的网络请求。

this.cancelable = makeCancelable(fetch('url')));
        this.cancelable.promise
            .then((response)=>response.json())
            .then((responseData)=> {          
                console.log(responseData);                            
            }).catch((error)=> {
                console.log(error); 
            });
取消网络请求：

this.cancelable.cancel();

在项目中的使用
为了提高React Native应用的性能，我们需要在组件卸载的时候不仅要主动释放掉所持有的资源，也要取消所发出的一些异步请求操作。

componentWillUnmount() {      
  this.cancelable.cancel();
}

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

184.   #### defer和async的区别(坚果云)

先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：
```js
<script src="script.js"></script>
```
没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
```js
<script async src="script.js"></script>
```
有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。
```js
<script defer src="myscript.js"></script>
```
有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

然后从实用角度来说呢，首先把所有脚本都丢到 </body> 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。

接着，我们来看一张图咯：

![avatar](https://img-blog.csdn.net/20180213144611105?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZnVuY3Rpb25fXw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。

此图告诉我们以下几个要点：

defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）
它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的
关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用
async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行
仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics

https://blog.csdn.net/function__/article/details/79321540

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

184. #### 后端的MVC

##### 题目：后端的MVC(海康二面)

MVC是开发所有软件所必须涉及的基本几个划分
M主要负责数据与模型，
V主要负责显示
C主要负责交互与业务
所以不管是前端还是后端，都是有MVC的。
MVC是一个对于软件简单的抽象，不管是M还是V，还是C都是有很多细分的。
所以理解MVC是一种业务抽象是非常重要的。

前端MVC
前端流行的MVVM就是对于前端MVC结构的一次重新定义。
特别是angular这样的框架出来后，前端的MVC就非常完善了。
再加上SPA与混合APP的流行，MVC在前端就是一个完整的体系。
同理后端一样是有MVC的。

后端MVC
基本上所有的后端框架都是声称支持MVC的。所以相对于前端来讲，后端的MVC是更加清楚的。
后端的
M主要是指数据库，文件等
V主要是指包括HTML模板，HTML的组装，其它的动态UI显示技术
C是一样的，但是一般的象HTTP请求都包括了路由请求，很多HTTP模式化的业务都抽象成了对应的专用软件，比如web server, session 服务器， 队列。C当然包括业务逻辑。而业务逻辑本身就有很多种。包括搜索引擎，机器学习等，都可以归于业务逻辑。

但是很可惜的是，最近因为前端技术的飞速发展，导致很多人又开始概念不清了。
将Web前端与服务器View混为一谈，将服务器前后端与Web前后端混为一谈。

前端一般是我们对Web前端简称，并非是对所有的东西的简单称。
但是前端本身是一个可以非常广泛的概念，只要是东西必定是有前后端的。一支笔还有前后端。
你非要将服务器（通常所说的后端技术）前端也称为前端，然后与Web前端混淆，我相信你只是在耍流氓。
所以我不太建议后端开发体系中非要再搞一个所谓的服务器前端。

下面简单将前后端与MVC作个归纳：

item|前端|后端
-|-|-
M|json、xml、html数据等|数据库和文件等
V|模板引擎、模板片段等|HTML模板
C|JS、业务逻辑、HTTP请求交互（AJAX, JSONP, WEBSOCKET)|HTTP请求路由、搜索引擎、数据分析、文件服务

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

185. #### 简单讲讲适配器模式

##### 题目：简单讲讲适配器模式(海康二面)

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

186. #### rustful接口原则

##### 题目：rustful接口原则(海康二面)

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

187. #### 执行上下文变量声明和函数声明

##### 题目：执行上下文，变量声明和函数声明(字节跳动)

```js
function Byte () {
    getName = function () {
        console.log(1);
    }
    return this;
}
Byte.getName = function () {
    console.log(2);
}
Byte.prototype.getName = function () {
    console.log(3);
}
var getName = function () {
    console.log(4);
}
function getName () {
    console.log(5);
}
Byte.getName();
getName();
Byte().getName();
getName();
new Byte.getName();
new Byte().getName();
// 2 4 1 1 2 3
```

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

188. #### _.get()实现

##### 题目：_.get()实现(字节跳动)


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

189. #### lodash 的 深克隆实现

##### 题目：lodash 的 深克隆实现(字节跳动)
```js
深克隆
对象类型判断
const isType = obj => {
    return Object.prototype.toString.call(obj);
}
正则处理
const getRegExp = reg => {
    let flags = '';
    if (reg.global) {
        flags += 'g';
    }
    if (reg.ignoreCase) {
         flags += 'i';
    }
    if (reg.multiline) {
        flags += 'm';
    }
    return flags;
};
cloneDeep

const cloneDeep = parent => {
    const parents = [];
    const children = [];
    const _clone = parent => {
        if (parent === null) {
            return null;
        }
        if (typeof parent !== 'object') {
            return parent;
        }
        let child;
        if (isType(parent) === '[object Array]') {
            child = [];
        } else if (isType(parent) === '[object Date]') {
            child = new Date(parent.getTime());
        } else if (isType(parent) === '[object RegExp]') {
            child = new RegExp(parent.source, getRegExp(parent));
            if (parent.lastIndex) {
                child.lastIndex = parent.lastIndex;
            }
        } else {
            let proto = Object.getPrototypeOf(parent);
            child = Object.create(proto);
        }
        let index = parents.indexOf(parent);
        if (index !== -1) {
            return children[index];
        }
        parents.push(parent);
        children.push(child);
        for (let i in parent) {
            child[i] = _clone(parent[i]);
        }
        return child;
    }
    return _clone(parent);
}
function P () {
    this.name = 'Lee';
}
P.prototype.getName = function () {
    return this.name;
}
// 测试1
let parent = {
    a: 1,
    b: '2',
    c: true,
    d: /[a-z][A-Z]/,
    e: function () {
        console.log(this.a);
    },
    f: new P(),
    g: new Date(),
    h: [1, '2', false, new P(), new Date(), /[0-9]/]
}
child = cloneDeep(parent);
// 测试2
let parent2 = {
    a: 1,
    b: '2',
    c: true,
    d: /[a-z][A-Z]/,
    e: function () {
        console.log(this.a);
    },
    f: new P(),
    g: new Date()
}
parent2.h = parent2;
child2 = cloneDeep(parent2);
```


---

[[↑] 回到顶部](#awsome-knowledge-front-end)

190. #### ts和js的区别，为什么要选择使用ts？

##### 题目：ts和js的区别，为什么要选择使用ts？(字节跳动)
javascript和typescript的区别一：概念对比

JavaScript 是一种轻量级的解释性脚本语言，无需编译，可嵌入到 HTML 页面中，在浏览器端执行，能够实现浏览器端丰富的交互功能，为用户带来流畅多样的用户体验。

TypeScript代码保存在ts文件中，ts文件经过编译之后会生成一个js文件，任何有效的JavaScript代码都可以直接作为TypeScript代码编译，只不过编译过后的代码与原JavaScript代码相同，TypeScript代码编译后则会转换为对应的JavaScript代码。

javascript和typescript的区别二：内容对比

1、TypeScript 引入了 JavaScript 中没有的“类”概念。

虽然ES6已经支持类，但是TypeScript与ES6的类还是不完全一样的，ts代码可以通过类型注解声明变量的类型。

2、TypeScript 中的数据要求带有明确的类型，JavaScript不要求。

3、TypeScript 通过类型注解提供编译时的静态类型检查。



let str: string;//ts代码

let str;//编译生成的js代码

通过对比可以清晰的看到，在ts代码中可以在声明变量的时候加上": 类型"来描述变量的类型，即类型注解。

4、TypeScript 从核心语言方面和类概念的模塑方面对 JavaScript 对象模型进行扩展。

5、JavaScript 代码可以在无需任何修改的情况下与 TypeScript 一同工作，同时可以使用编译器将 TypeScript 代码转换为 JavaScript。

6、TypeScript 为函数提供了缺省参数值。

在TypeScript的函数中我们可以给每个参数提供类型注解，还能为函数提供返回类型注解（在参数列表后的":类型"），同时TypeScript可以在参数名右边加上一个？表示可选参数。

7、TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。

javascript和typescript的区别三：优点对比

javascript优点：

1、人气：JavaScript 的开发者社区仍然是巨大而活跃的，在社区中可以很方便地找到大量成熟的开发项目和可用资源。

2、学习曲线：由于 JavaScript 语言发展的较早，也较为成熟，所以仍有一大批开发人员坚持使用他们熟悉的脚本语言 JavaScript，而不是学习 TypeScript。

3、本地浏览器支持：TypeScript 代码需要被编译（输出 JavaScript 代码），这是 TypeScript 代码执行时的一个额外的步骤。

4、不需要注释：为了充分利用 TypeScript 特性，开发人员需要不断注释他们的代码，这可能会使项目效率降低。

5、灵活性：有些开发人员更喜欢 JavaScript 的灵活性。

typescript优点：

1、便于开发人员做注释。

2、能帮助开发人员检测出错误并修改。

3、TypeScript工具使重构变得容易、快捷。

4、TypeScript 引入了 JavaScript 中没有的“类”概念。

5、TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。

6、类型安全功能能在编码期间检测错误，这为开发人员创建了一个更高效的编码和调试过程。

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

191. #### 讲讲订阅-发布模式，有几种实现方式

##### 题目：讲讲订阅-发布模式，有几种实现方式(字节跳动)
关键词：listener、Object.defineProperty

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 事件是如何实现的

##### 题目：事件是如何实现的(字节跳动)
关键词：订阅-发布模式

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 许多if的优化

##### 题目：许多if的优化(个推一面)
关键词：1. map 2. weakmap 3. switch 4. generate 5. 函数编程 6. 洋葱模型

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 输出什么
##### 题目：{}+13(个推一面)
##### 答案是：[object Object]13

突然发现面试官错了，他说`{}`不执行,答案是`13`

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 输出什么

##### 题目：[]+13(个推一面)
##### 答案：13

突然发现面试官错了，他说执行会生成很奇怪的东西,答案是`[Object Arr]13`

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 浏览器的新特性和js的新特性

##### 题目：浏览器的新特性和js的新特性(个推一面)

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 在两个上万的数组中找出重复的数据

##### 题目：在两个上万的数组中找出重复的数据(个推一面)
方法一：
1. 申明第三个数组
2. 遍历第一个数组
3. 如果第二个数组中存在遍历中的数据，则将数据塞进第三个数组
4. 遍历完成返回第三个数组
方法二：
重复方法一的操作结合二分查找，比10000*10000优化了一半
方法三：
用set
1. 遍历第一个数组
2. 用set.has()判断数据在第二个数组中是否存在O(1)
3. 存在则返回

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### set是如何实现的

##### 题目：set是如何实现的(个推一面)

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 执行结果

##### 题目：let {...a}=[1,2,3](个推一面)
##### 答案：{0: 1, 1: 2, 2: 3}
---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 执行结果

##### 题目：let {...a}={a:1,a:2,a:3}(个推一面)
##### 答案：{a: 3}
---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 类数组
##### 题目：类数组(个推一面)

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### exports和export的区别(个推一面)
```js
//a.js
const a=13
export a 
//b.js
import {a} from 'a.js'
```
a可以重新赋值吗

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 判断两个嵌套对象是否相等(个推一面)
```js
//a.js
const a=13
export a 
//b.js
import {a} from 'a.js'
```
a可以重新赋值吗

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

192. #### 遍历对象的方法(个推一面)
```js
//a.js
const a=13
export a 
//b.js
import {a} from 'a.js'
```
a可以重新赋值吗

---

[[↑] 回到顶部](#awsome-knowledge-front-end)

key

nexttick

change() {
    this.a  = 2
    console.log(this.a)
    console.log(div.innerText)
}

sum(1)(2)(3) == 6